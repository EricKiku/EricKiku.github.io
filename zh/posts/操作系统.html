<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.60" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://mister-hope.github.io/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"><meta property="og:site_name" content="博客"><meta property="og:title" content="操作系统笔记"><meta property="og:description" content=""" 一、操作系统 1. 操作系统层次 image-20221024155305809 2.定义 操作系统(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2023-02-12T06:26:17.000Z"><meta property="article:modified_time" content="2023-02-12T06:26:17.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"操作系统笔记","image":[""],"dateModified":"2023-02-12T06:26:17.000Z","author":[]}</script><title>操作系统笔记 | 博客</title><meta name="description" content=""" 一、操作系统 1. 操作系统层次 image-20221024155305809 2.定义 操作系统(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供用户和其他软件方便的接口和环境，它是计算机系统中最基本的系统软件">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d1e1f;
      }

      html,
      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="preload" href="/assets/style-fea2a9cc.css" as="style"><link rel="stylesheet" href="/assets/style-fea2a9cc.css">
    <link rel="modulepreload" href="/assets/app-e88a0bdb.js"><link rel="modulepreload" href="/assets/framework-61af4b36.js"><link rel="modulepreload" href="/assets/操作系统.html-ace57083.js"><link rel="modulepreload" href="/assets/操作系统.html-31c2c2c7.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container has-toc"><!--[--><header class="navbar" id="navbar"><div class="navbar-start"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><!----><!--]--><a href="/zh/" class="brand"><img class="logo" src="/roundmylogo.png" alt="博客"><!----><span class="site-name hide-in-pad">博客</span></a><!--[--><!----><!--]--></div><div class="navbar-center"><!--[--><!----><!--]--><nav class="nav-links"><div class="nav-item hide-in-mobile"><a href="/zh/" class="nav-link" aria-label="博客主页"><span class="font-icon icon iconfont icon-home" style=""></span>博客主页<!----></a></div><div class="nav-item hide-in-mobile"><a href="/zh/fontend/" class="nav-link" aria-label="前端"><span class="font-icon icon iconfont icon-html" style=""></span>前端<!----></a></div><div class="nav-item hide-in-mobile"><a href="/zh/backend/" class="nav-link" aria-label="后端"><span class="font-icon icon iconfont icon-java" style=""></span>后端<!----></a></div><div class="nav-item hide-in-mobile"><a href="/zh/posts/" class="nav-link active" aria-label="博文"><span class="font-icon icon iconfont icon-note" style=""></span>博文<!----></a></div></nav><!--[--><!----><!--]--></div><div class="navbar-end"><!--[--><!----><!--]--><!----><div class="nav-item"><a class="repo-link" href="https://github.com/vuepress-theme-hope/vuepress-theme-hope" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><!----><!----><!--[--><!----><!--]--><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside class="sidebar" id="sidebar"><!--[--><!----><!--]--><ul class="sidebar-links"><li><!--[--><a href="/zh/posts/" class="nav-link sidebar-link sidebar-page" aria-label="随笔博文"><span class="font-icon icon iconfont icon-note" style=""></span>随笔博文<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zh/posts/%E5%B7%A5%E5%85%B7%E5%BA%93.html" class="nav-link sidebar-link sidebar-page" aria-label="封装工具库"><span class="font-icon icon iconfont icon-org-utility" style=""></span>封装工具库<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zh/posts/%E8%83%8C%E6%99%AF%E5%90%B8%E9%99%84%E9%BC%A0%E6%A0%87%E5%8A%A8%E6%80%81%E4%BB%A3%E7%A0%81.html" class="nav-link sidebar-link sidebar-page" aria-label="背景动态代码"><span class="font-icon icon iconfont icon-org-utility" style=""></span>背景动态代码<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zh/posts/%E6%97%A5%E8%AF%AD%E7%AC%94%E8%AE%B0.html" class="nav-link sidebar-link sidebar-page" aria-label="日语笔记"><span class="font-icon icon iconfont icon-icon-test" style=""></span>日语笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" class="router-link-active router-link-exact-active nav-link active sidebar-link sidebar-page active" aria-label="操作系统笔记"><span class="font-icon icon iconfont icon-caozuoxitong" style=""></span>操作系统笔记<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-操作系统层次" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 操作系统层次"><!---->1. 操作系统层次<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-定义" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.定义"><!---->2.定义<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-系统资源的管理者" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.系统资源的管理者"><!---->1.系统资源的管理者<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-作为硬件和用户之间的接口" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.作为硬件和用户之间的接口"><!---->2.作为硬件和用户之间的接口<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-并发" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.并发"><!---->1.并发<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-共享" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.共享"><!---->2.共享<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#并发和共享的关系" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="并发和共享的关系"><!---->并发和共享的关系<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-虚拟" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.虚拟"><!---->3.虚拟<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-异步" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.异步"><!---->4.异步<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-手工操作阶段" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.手工操作阶段"><!---->1.手工操作阶段<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-单道批处理系统" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.单道批处理系统"><!---->2.单道批处理系统<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-多道批处理系统" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.多道批处理系统"><!---->3.多道批处理系统<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-分时操作系统" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.分时操作系统"><!---->4.分时操作系统<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-实时操作系统" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.实时操作系统"><!---->5.实时操作系统<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-运行机制" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 运行机制"><!---->1. 运行机制<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-两种指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="（1）两种指令"><!---->（1）两种指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-两种处理器状态" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="（2）两种处理器状态"><!---->（2）两种处理器状态<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-两种程序" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="（3）两种程序"><!---->（3）两种程序<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-操作系统的内核" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.操作系统的内核"><!---->2.操作系统的内核<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-操作系统体系结构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.操作系统体系结构"><!---->3.操作系统体系结构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-中断的概念和作用" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.中断的概念和作用"><!---->1.中断的概念和作用<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-中断的分类" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.中断的分类"><!---->2.中断的分类<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#外中断处理过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="外中断处理过程"><!---->外中断处理过程<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-进程的组成" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 进程的组成"><!---->1. 进程的组成<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-进程的组织" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 进程的组织"><!---->2. 进程的组织<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-进程的特征" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.进程的特征"><!---->3.进程的特征<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-进程的状态" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 进程的状态"><!---->1. 进程的状态<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-进程的转换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.进程的转换"><!---->2.进程的转换<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-原语" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.原语"><!---->1.原语<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-共享存储" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.共享存储"><!---->1.共享存储<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-管道通信" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.管道通信"><!---->2.管道通信<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-消息传递" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 消息传递"><!---->3. 消息传递<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-什么是线程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 什么是线程"><!---->1. 什么是线程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-线程的属性" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.线程的属性"><!---->2.线程的属性<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-线程的实现方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.线程的实现方式"><!---->3.线程的实现方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-多线程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.多线程"><!---->4.多线程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-调度概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 调度概念"><!---->1. 调度概念<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-三个层次" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 三个层次"><!---->2. 三个层次<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-进程调度时机" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 进程调度时机"><!---->3. 进程调度时机<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-进程调度的方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 进程调度的方式"><!---->4. 进程调度的方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-进程切换与过程" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 进程切换与过程"><!---->5. 进程切换与过程<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_6-调度算法指标" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6. 调度算法指标"><!---->6. 调度算法指标<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-cpu利用率" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. CPU利用率"><!---->1. CPU利用率<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-系统吞吐量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 系统吞吐量"><!---->2. 系统吞吐量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-周转时间" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 周转时间"><!---->3. 周转时间<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-等待时间" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.等待时间"><!---->4.等待时间<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-响应时间" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.响应时间"><!---->5.响应时间<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-fcfs" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. FCFS"><!---->1. FCFS<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-sjf" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. SJF"><!---->2. SJF<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-hrrn" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. HRRN"><!---->3. HRRN<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-rr" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.RR"><!---->4.RR<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-优先级调度算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5. 优先级调度算法"><!---->5. 优先级调度算法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_6-多级反馈队列调度" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6. 多级反馈队列调度"><!---->6. 多级反馈队列调度<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-进程同步" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.进程同步"><!---->1.进程同步<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-进程互斥" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.进程互斥"><!---->2.进程互斥<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-进程互斥的软件实现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.进程互斥的软件实现"><!---->3.进程互斥的软件实现<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-单标签法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 单标签法"><!---->1. 单标签法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-双标志检查法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 双标志检查法"><!---->2. 双标志检查法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-双标志后检查法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.双标志后检查法"><!---->3.双标志后检查法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-peterson算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.Peterson算法"><!---->4.Peterson算法<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-进程互斥的硬件实现" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.进程互斥的硬件实现"><!---->4.进程互斥的硬件实现<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-中断屏蔽方法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 中断屏蔽方法"><!---->1. 中断屏蔽方法<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-testandset指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.TestAndSet指令"><!---->2.TestAndSet指令<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-swap指令" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.Swap指令"><!---->3.Swap指令<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-整形信号量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 整形信号量"><!---->1. 整形信号量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-记录型信号量" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2. 记录型信号量"><!---->2. 记录型信号量<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-信号量机制实现进程互斥" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3. 信号量机制实现进程互斥"><!---->3. 信号量机制实现进程互斥<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-信号量机制实现进程同步" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4. 信号量机制实现进程同步"><!---->4. 信号量机制实现进程同步<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-实现进程的同步关系" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.实现进程的同步关系"><!---->5.实现进程的同步关系<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-多生产者多消费者" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 多生产者多消费者"><!---->1. 多生产者多消费者<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-管程解决生产者消费者问题" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.管程解决生产者消费者问题"><!---->1.管程解决生产者消费者问题<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-死锁、饥饿、死循环" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.死锁、饥饿、死循环"><!---->1.死锁、饥饿、死循环<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-死锁发生的条件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.死锁发生的条件"><!---->2.死锁发生的条件<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-死锁的处理策略" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.死锁的处理策略"><!---->3.死锁的处理策略<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-预防死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.预防死锁"><!---->4.预防死锁<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-破坏互斥条件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.破坏互斥条件"><!---->1.破坏互斥条件<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-破坏不剥夺条件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.破坏不剥夺条件"><!---->2.破坏不剥夺条件<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-破坏请求和保持条件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.破坏请求和保持条件"><!---->3.破坏请求和保持条件<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-破坏循环等待条件" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.破坏循环等待条件"><!---->4.破坏循环等待条件<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-避免死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.避免死锁"><!---->5.避免死锁<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-什么是安全序列" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1. 什么是安全序列"><!---->1. 什么是安全序列<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-银行家算法" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.银行家算法"><!---->2.银行家算法<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_6-死锁的检测和解除" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="6.死锁的检测和解除"><!---->6.死锁的检测和解除<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-死锁的检测" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.死锁的检测"><!---->1.死锁的检测<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-解除死锁" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.解除死锁"><!---->2.解除死锁<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-装入方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.装入方式"><!---->1.装入方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-链接方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.链接方式"><!---->2.链接方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-内存保护" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.内存保护"><!---->3.内存保护<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-覆盖与交换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.覆盖与交换"><!---->4.覆盖与交换<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-内存空间的分配与回收" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="5.内存空间的分配与回收"><!---->5.内存空间的分配与回收<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-连续分配管理方式" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="（1）连续分配管理方式"><!---->（1）连续分配管理方式<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-非连续分配" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="（2）非连续分配"><!---->（2）非连续分配<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-基本分页存储管理" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.基本分页存储管理"><!---->1.基本分页存储管理<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-基本概念" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="1.基本概念"><!---->1.基本概念<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-地址转换" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.地址转换"><!---->2.地址转换<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-基本地址变换机构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="3.基本地址变换机构"><!---->3.基本地址变换机构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-具有快表的地址变换机构" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="4.具有快表的地址变换机构"><!---->4.具有快表的地址变换机构<!----></a><ul class="sidebar-sub-headers"></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#小结" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="小结"><!---->小结<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-两级页表" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="2.两级页表"><!---->2.两级页表<!----></a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#解决问题1" class="router-link-active router-link-exact-active nav-link sidebar-link heading" aria-label="解决问题1"><!---->解决问题1<!----></a><ul class="sidebar-sub-headers"></ul></li></ul></li></ul><!--]--></li><li><!--[--><a href="/zh/posts/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.html" class="nav-link sidebar-link sidebar-page" aria-label="项目笔记"><span class="font-icon icon iconfont icon-project" style=""></span>项目笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li><li><!--[--><a href="/zh/posts/%E7%AE%97%E6%B3%95.html" class="nav-link sidebar-link sidebar-page" aria-label="算法笔记"><span class="font-icon icon iconfont icon-suanfaku" style=""></span>算法笔记<!----></a><ul class="sidebar-sub-headers"></ul><!--]--></li></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!--[--><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><span class="font-icon icon iconfont icon-caozuoxitong" style=""></span>操作系统笔记</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/EricKiku" target="_blank" rel="noopener noreferrer">EricKiku</a></span><span property="author" content="EricKiku"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2023-02-11T15:21:15.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 34 分钟</span><meta property="timeRequired" content="PT34M"></span><span class="page-category-info" aria-label="分类🌈" data-balloon-pos="down"><svg xmlns="http://www.w3.org/2000/svg" class="icon category-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="category icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zM147.556 553.478H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zM593.927 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zM730.22 920.502H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z"></path></svg><span class="page-category-item category5 clickable" role="navigation">课程</span><span class="page-category-item category0 clickable" role="navigation">随笔</span><meta property="articleSection" content="课程,随笔"></span><!----></div><hr></div><div class="toc-place-holder"><aside id="toc"><div class="toc-header">此页内容<button class="print-button" title="print"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button></div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-操作系统层次" class="router-link-active router-link-exact-active toc-link level2">1. 操作系统层次</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-定义" class="router-link-active router-link-exact-active toc-link level2">2.定义</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-系统资源的管理者" class="router-link-active router-link-exact-active toc-link level2">1.系统资源的管理者</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-作为硬件和用户之间的接口" class="router-link-active router-link-exact-active toc-link level2">2.作为硬件和用户之间的接口</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-并发" class="router-link-active router-link-exact-active toc-link level2">1.并发</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-共享" class="router-link-active router-link-exact-active toc-link level2">2.共享</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#并发和共享的关系" class="router-link-active router-link-exact-active toc-link level2">并发和共享的关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-虚拟" class="router-link-active router-link-exact-active toc-link level2">3.虚拟</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-异步" class="router-link-active router-link-exact-active toc-link level2">4.异步</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-手工操作阶段" class="router-link-active router-link-exact-active toc-link level2">1.手工操作阶段</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-单道批处理系统" class="router-link-active router-link-exact-active toc-link level2">2.单道批处理系统</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-多道批处理系统" class="router-link-active router-link-exact-active toc-link level2">3.多道批处理系统</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-分时操作系统" class="router-link-active router-link-exact-active toc-link level2">4.分时操作系统</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-实时操作系统" class="router-link-active router-link-exact-active toc-link level2">5.实时操作系统</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-运行机制" class="router-link-active router-link-exact-active toc-link level2">1. 运行机制</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-两种指令" class="router-link-active router-link-exact-active toc-link level3">（1）两种指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-两种处理器状态" class="router-link-active router-link-exact-active toc-link level3">（2）两种处理器状态</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-两种程序" class="router-link-active router-link-exact-active toc-link level3">（3）两种程序</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-操作系统的内核" class="router-link-active router-link-exact-active toc-link level2">2.操作系统的内核</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-操作系统体系结构" class="router-link-active router-link-exact-active toc-link level2">3.操作系统体系结构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-中断的概念和作用" class="router-link-active router-link-exact-active toc-link level2">1.中断的概念和作用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-中断的分类" class="router-link-active router-link-exact-active toc-link level2">2.中断的分类</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#外中断处理过程" class="router-link-active router-link-exact-active toc-link level3">外中断处理过程</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-进程的组成" class="router-link-active router-link-exact-active toc-link level2">1. 进程的组成</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-进程的组织" class="router-link-active router-link-exact-active toc-link level2">2. 进程的组织</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-进程的特征" class="router-link-active router-link-exact-active toc-link level2">3.进程的特征</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-进程的状态" class="router-link-active router-link-exact-active toc-link level2">1. 进程的状态</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-进程的转换" class="router-link-active router-link-exact-active toc-link level2">2.进程的转换</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-原语" class="router-link-active router-link-exact-active toc-link level2">1.原语</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-共享存储" class="router-link-active router-link-exact-active toc-link level2">1.共享存储</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-管道通信" class="router-link-active router-link-exact-active toc-link level2">2.管道通信</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-消息传递" class="router-link-active router-link-exact-active toc-link level2">3. 消息传递</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-什么是线程" class="router-link-active router-link-exact-active toc-link level2">1. 什么是线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-线程的属性" class="router-link-active router-link-exact-active toc-link level2">2.线程的属性</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-线程的实现方式" class="router-link-active router-link-exact-active toc-link level2">3.线程的实现方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-多线程" class="router-link-active router-link-exact-active toc-link level2">4.多线程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-调度概念" class="router-link-active router-link-exact-active toc-link level2">1. 调度概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-三个层次" class="router-link-active router-link-exact-active toc-link level2">2. 三个层次</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-进程调度时机" class="router-link-active router-link-exact-active toc-link level2">3. 进程调度时机</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-进程调度的方式" class="router-link-active router-link-exact-active toc-link level2">4. 进程调度的方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-进程切换与过程" class="router-link-active router-link-exact-active toc-link level2">5. 进程切换与过程</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_6-调度算法指标" class="router-link-active router-link-exact-active toc-link level2">6. 调度算法指标</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-cpu利用率" class="router-link-active router-link-exact-active toc-link level3">1. CPU利用率</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-系统吞吐量" class="router-link-active router-link-exact-active toc-link level3">2. 系统吞吐量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-周转时间" class="router-link-active router-link-exact-active toc-link level3">3. 周转时间</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-等待时间" class="router-link-active router-link-exact-active toc-link level3">4.等待时间</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-响应时间" class="router-link-active router-link-exact-active toc-link level3">5.响应时间</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-fcfs" class="router-link-active router-link-exact-active toc-link level2">1. FCFS</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-sjf" class="router-link-active router-link-exact-active toc-link level2">2. SJF</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-hrrn" class="router-link-active router-link-exact-active toc-link level2">3. HRRN</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-rr" class="router-link-active router-link-exact-active toc-link level2">4.RR</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-优先级调度算法" class="router-link-active router-link-exact-active toc-link level2">5. 优先级调度算法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_6-多级反馈队列调度" class="router-link-active router-link-exact-active toc-link level2">6. 多级反馈队列调度</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-进程同步" class="router-link-active router-link-exact-active toc-link level2">1.进程同步</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-进程互斥" class="router-link-active router-link-exact-active toc-link level2">2.进程互斥</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-进程互斥的软件实现" class="router-link-active router-link-exact-active toc-link level2">3.进程互斥的软件实现</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-单标签法" class="router-link-active router-link-exact-active toc-link level3">1. 单标签法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-双标志检查法" class="router-link-active router-link-exact-active toc-link level3">2. 双标志检查法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-双标志后检查法" class="router-link-active router-link-exact-active toc-link level3">3.双标志后检查法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-peterson算法" class="router-link-active router-link-exact-active toc-link level3">4.Peterson算法</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-进程互斥的硬件实现" class="router-link-active router-link-exact-active toc-link level2">4.进程互斥的硬件实现</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-中断屏蔽方法" class="router-link-active router-link-exact-active toc-link level3">1. 中断屏蔽方法</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-testandset指令" class="router-link-active router-link-exact-active toc-link level3">2.TestAndSet指令</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-swap指令" class="router-link-active router-link-exact-active toc-link level3">3.Swap指令</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-整形信号量" class="router-link-active router-link-exact-active toc-link level2">1. 整形信号量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-记录型信号量" class="router-link-active router-link-exact-active toc-link level2">2. 记录型信号量</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-信号量机制实现进程互斥" class="router-link-active router-link-exact-active toc-link level2">3. 信号量机制实现进程互斥</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-信号量机制实现进程同步" class="router-link-active router-link-exact-active toc-link level2">4. 信号量机制实现进程同步</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-实现进程的同步关系" class="router-link-active router-link-exact-active toc-link level2">5.实现进程的同步关系</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-多生产者多消费者" class="router-link-active router-link-exact-active toc-link level2">1. 多生产者多消费者</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-管程解决生产者消费者问题" class="router-link-active router-link-exact-active toc-link level2">1.管程解决生产者消费者问题</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-死锁、饥饿、死循环" class="router-link-active router-link-exact-active toc-link level2">1.死锁、饥饿、死循环</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-死锁发生的条件" class="router-link-active router-link-exact-active toc-link level2">2.死锁发生的条件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-死锁的处理策略" class="router-link-active router-link-exact-active toc-link level2">3.死锁的处理策略</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-预防死锁" class="router-link-active router-link-exact-active toc-link level2">4.预防死锁</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-破坏互斥条件" class="router-link-active router-link-exact-active toc-link level3">1.破坏互斥条件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-破坏不剥夺条件" class="router-link-active router-link-exact-active toc-link level3">2.破坏不剥夺条件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-破坏请求和保持条件" class="router-link-active router-link-exact-active toc-link level3">3.破坏请求和保持条件</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-破坏循环等待条件" class="router-link-active router-link-exact-active toc-link level3">4.破坏循环等待条件</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-避免死锁" class="router-link-active router-link-exact-active toc-link level2">5.避免死锁</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-什么是安全序列" class="router-link-active router-link-exact-active toc-link level3">1. 什么是安全序列</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-银行家算法" class="router-link-active router-link-exact-active toc-link level3">2.银行家算法</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_6-死锁的检测和解除" class="router-link-active router-link-exact-active toc-link level2">6.死锁的检测和解除</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-死锁的检测" class="router-link-active router-link-exact-active toc-link level3">1.死锁的检测</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-解除死锁" class="router-link-active router-link-exact-active toc-link level3">2.解除死锁</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-装入方式" class="router-link-active router-link-exact-active toc-link level2">1.装入方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-链接方式" class="router-link-active router-link-exact-active toc-link level2">2.链接方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-内存保护" class="router-link-active router-link-exact-active toc-link level2">3.内存保护</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-覆盖与交换" class="router-link-active router-link-exact-active toc-link level2">4.覆盖与交换</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_5-内存空间的分配与回收" class="router-link-active router-link-exact-active toc-link level2">5.内存空间的分配与回收</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-连续分配管理方式" class="router-link-active router-link-exact-active toc-link level3">（1）连续分配管理方式</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-非连续分配" class="router-link-active router-link-exact-active toc-link level3">（2）非连续分配</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-基本分页存储管理" class="router-link-active router-link-exact-active toc-link level2">1.基本分页存储管理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_1-基本概念" class="router-link-active router-link-exact-active toc-link level3">1.基本概念</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-地址转换" class="router-link-active router-link-exact-active toc-link level3">2.地址转换</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_3-基本地址变换机构" class="router-link-active router-link-exact-active toc-link level3">3.基本地址变换机构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_4-具有快表的地址变换机构" class="router-link-active router-link-exact-active toc-link level3">4.具有快表的地址变换机构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#小结" class="router-link-active router-link-exact-active toc-link level3">小结</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#_2-两级页表" class="router-link-active router-link-exact-active toc-link level2">2.两级页表</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/zh/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html#解决问题1" class="router-link-active router-link-exact-active toc-link level3">解决问题1</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> &quot;&quot;</h1><h1 id="一、操作系统" tabindex="-1"><a class="header-anchor" href="#一、操作系统" aria-hidden="true">#</a> 一、操作系统</h1><h2 id="_1-操作系统层次" tabindex="-1"><a class="header-anchor" href="#_1-操作系统层次" aria-hidden="true">#</a> 1. 操作系统层次</h2><figure><img src="/assets/images/image-20221024155305809.png" alt="image-20221024155305809" tabindex="0" loading="lazy"><figcaption>image-20221024155305809</figcaption></figure><h2 id="_2-定义" tabindex="-1"><a class="header-anchor" href="#_2-定义" aria-hidden="true">#</a> 2.定义</h2><p><code>操作系统</code>(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供用户和其他软件方便的接口和环境，它是计算机系统中最基本的<code>系统软件</code></p><h1 id="二、操作系统功能和目标" tabindex="-1"><a class="header-anchor" href="#二、操作系统功能和目标" aria-hidden="true">#</a> 二、操作系统功能和目标</h1><h2 id="_1-系统资源的管理者" tabindex="-1"><a class="header-anchor" href="#_1-系统资源的管理者" aria-hidden="true">#</a> 1.系统资源的管理者</h2><figure><img src="/assets/images/image-20221024160818996.png" alt="image-20221024160818996" tabindex="0" loading="lazy"><figcaption>image-20221024160818996</figcaption></figure><h2 id="_2-作为硬件和用户之间的接口" tabindex="-1"><a class="header-anchor" href="#_2-作为硬件和用户之间的接口" aria-hidden="true">#</a> 2.作为硬件和用户之间的接口</h2><figure><img src="/assets/images/image-20221025090622134.png" alt="image-20221025090622134" tabindex="0" loading="lazy"><figcaption>image-20221025090622134</figcaption></figure><p>用户接口：</p><figure><img src="/assets/images/image-20221025092059509.png" alt="image-20221025092059509" tabindex="0" loading="lazy"><figcaption>image-20221025092059509</figcaption></figure><h1 id="三、操作系统4个特征" tabindex="-1"><a class="header-anchor" href="#三、操作系统4个特征" aria-hidden="true">#</a> 三、操作系统4个特征</h1><p>​</p><figure><img src="/assets/images/image-20221025093101472.png" alt="image-20221025093101472" tabindex="0" loading="lazy"><figcaption>image-20221025093101472</figcaption></figure><h2 id="_1-并发" tabindex="-1"><a class="header-anchor" href="#_1-并发" aria-hidden="true">#</a> 1.并发</h2><p><code>并发</code>：指两个或多个事件在同一时间间隔发生。这些事件<code>宏观上是同时发生</code>,但<code>微观上是交替发生的</code></p><p><code>并行</code>：指两个或多个事件在同一时刻同时发生</p><h2 id="_2-共享" tabindex="-1"><a class="header-anchor" href="#_2-共享" aria-hidden="true">#</a> 2.共享</h2><p><code>共享</code>：即资源共享，是指系统中的资源可供内存中多个并发执行的进程使用共同使用</p><figure><img src="/assets/images/image-20221025093849891.png" alt="image-20221025093849891" tabindex="0" loading="lazy"><figcaption>image-20221025093849891</figcaption></figure><p>所谓同时，也是宏观上的，微观上，这些进程可能也是交替进行的</p><h2 id="并发和共享的关系" tabindex="-1"><a class="header-anchor" href="#并发和共享的关系" aria-hidden="true">#</a> 并发和共享的关系</h2><p>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义</p><p>如果失去共享性，则QQ和微信等不能同时访问硬盘资源，就无法实现同步发送文件，也就无法并发</p><h2 id="_3-虚拟" tabindex="-1"><a class="header-anchor" href="#_3-虚拟" aria-hidden="true">#</a> 3.虚拟</h2><p><code>虚拟</code>是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上市用户感受到的。</p><figure><img src="/assets/images/image-20221025095831537.png" alt="image-20221025095831537" tabindex="0" loading="lazy"><figcaption>image-20221025095831537</figcaption></figure><h2 id="_4-异步" tabindex="-1"><a class="header-anchor" href="#_4-异步" aria-hidden="true">#</a> 4.异步</h2><p><code>异步</code>是指，在多到程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是以某种顺序向前推进</p><h1 id="四、操作系统的发展与分类" tabindex="-1"><a class="header-anchor" href="#四、操作系统的发展与分类" aria-hidden="true">#</a> 四、操作系统的发展与分类</h1><h2 id="_1-手工操作阶段" tabindex="-1"><a class="header-anchor" href="#_1-手工操作阶段" aria-hidden="true">#</a> 1.手工操作阶段</h2><p>主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低</p><h2 id="_2-单道批处理系统" tabindex="-1"><a class="header-anchor" href="#_2-单道批处理系统" aria-hidden="true">#</a> 2.单道批处理系统</h2><p>引入了<code>脱机输入/输出技术</code>，使用磁带完成。并<code>监督程序</code>负责控制作业的输入、输出</p><p>监督程序就是操作系统的雏形</p><p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p><p>主要缺点：<code>内存中仅能有一道程序运行</code>，只有程序结束之后才能调入下一道程序。<code>CPU有大量的时间在空闲等待I/O完成</code>。资源利用率依然很低</p><h2 id="_3-多道批处理系统" tabindex="-1"><a class="header-anchor" href="#_3-多道批处理系统" aria-hidden="true">#</a> 3.多道批处理系统</h2><p>操作系统正式诞生。</p><p>主要优点：多道程序<code>并发</code>执行，<code>共享</code>计算机资源。<code>资源利用率大幅提升</code>，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p><p>主要缺点：用户响应时间长，<code>没有人机交互功能</code>，用户提交之后不能控制自己作业的执行，只能等待计算机处理完成</p><h2 id="_4-分时操作系统" tabindex="-1"><a class="header-anchor" href="#_4-分时操作系统" aria-hidden="true">#</a> 4.分时操作系统</h2><p>分时操作系统：计算机以<code>时间片</code>为单位<code>轮流为各个用户服务</code>，各个用户可以通过终端与计算机进行交互。</p><p>主要优点：用户请求可以被即是响应，解决人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到其他人的存在</p><p>主要缺点：<code>不能优先处理一些紧急任务</code>，操作系统对每个用户都是完全公平的，循环地为每个用户服务一个时间片，不区分任务的紧急性</p><h2 id="_5-实时操作系统" tabindex="-1"><a class="header-anchor" href="#_5-实时操作系统" aria-hidden="true">#</a> 5.实时操作系统</h2><p>计算机系统接收到信号之后及时进行处理，并且要在规定时间内处理完成事件。实时操作系统的主要特点是<code>及时性和可靠性</code></p><p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需要排队</p><p>​ <img src="/assets/images/image-20221025192855776.png" alt="image-20221025192855776" loading="lazy"></p><h1 id="五、os的运行机制和体系结构" tabindex="-1"><a class="header-anchor" href="#五、os的运行机制和体系结构" aria-hidden="true">#</a> 五、OS的运行机制和体系结构</h1><h2 id="_1-运行机制" tabindex="-1"><a class="header-anchor" href="#_1-运行机制" aria-hidden="true">#</a> 1. 运行机制</h2><h3 id="_1-两种指令" tabindex="-1"><a class="header-anchor" href="#_1-两种指令" aria-hidden="true">#</a> （1）两种指令</h3><ul><li><p>特权指令：高危指令，比如内存清空指令。<code>用户程序无法使用</code></p></li><li><p>非特权指令：普通指令。<code>用户程序可以使用</code></p></li></ul><h3 id="_2-两种处理器状态" tabindex="-1"><a class="header-anchor" href="#_2-两种处理器状态" aria-hidden="true">#</a> （2）两种处理器状态</h3><ul><li><p>用户态(目态)：此时CPU只能执行非特权指令</p></li><li><p>和心态(管态)：特权指令，非特权指令都可以执行</p></li></ul><blockquote><p>使用程序状态字寄存器（PSW)中的某标志位来标识当前处理器处于什么状态</p></blockquote><h3 id="_3-两种程序" tabindex="-1"><a class="header-anchor" href="#_3-两种程序" aria-hidden="true">#</a> （3）两种程序</h3><ul><li>内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态</li><li>应用程序：普通应用程序只能执行非特权指令，运行在用户态</li></ul><h2 id="_2-操作系统的内核" tabindex="-1"><a class="header-anchor" href="#_2-操作系统的内核" aria-hidden="true">#</a> 2.操作系统的内核</h2><figure><img src="/assets/images/image-20221025194519627.png" alt="image-20221025194519627" tabindex="0" loading="lazy"><figcaption>image-20221025194519627</figcaption></figure><figure><img src="/assets/images/image-20221025194553756.png" alt="image-20221025194553756" tabindex="0" loading="lazy"><figcaption>image-20221025194553756</figcaption></figure><h2 id="_3-操作系统体系结构" tabindex="-1"><a class="header-anchor" href="#_3-操作系统体系结构" aria-hidden="true">#</a> 3.操作系统体系结构</h2><figure><img src="/assets/images/image-20221025194942189.png" alt="image-20221025194942189" tabindex="0" loading="lazy"><figcaption>image-20221025194942189</figcaption></figure><h1 id="六、中断和异常" tabindex="-1"><a class="header-anchor" href="#六、中断和异常" aria-hidden="true">#</a> 六、中断和异常</h1><h2 id="_1-中断的概念和作用" tabindex="-1"><a class="header-anchor" href="#_1-中断的概念和作用" aria-hidden="true">#</a> 1.中断的概念和作用</h2><ol><li>当中断发生时，CPU立即进入<code>核心态</code></li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ol><p>发生中断，就意味着需要操作系统介入，开始管理工作，由于操作系统的管理工作需要使用特权指令，所以需要CPU<code>从用户态转为核心态，使操作系统获得计算机的控制权</code>，有了中断，才能实现多道程序并发执行</p><p><code>用户态到核心态</code>是通过中断实现的，并且只有中断这一个途径</p><h2 id="_2-中断的分类" tabindex="-1"><a class="header-anchor" href="#_2-中断的分类" aria-hidden="true">#</a> 2.中断的分类</h2><figure><img src="/assets/images/image-20221026080950359.png" alt="image-20221026080950359" tabindex="0" loading="lazy"><figcaption>image-20221026080950359</figcaption></figure><h3 id="外中断处理过程" tabindex="-1"><a class="header-anchor" href="#外中断处理过程" aria-hidden="true">#</a> 外中断处理过程</h3><figure><img src="/assets/images/image-20221026081308106.png" alt="image-20221026081308106" tabindex="0" loading="lazy"><figcaption>image-20221026081308106</figcaption></figure><h1 id="七、系统调用" tabindex="-1"><a class="header-anchor" href="#七、系统调用" aria-hidden="true">#</a> 七、系统调用</h1><p><code>系统调用</code>是操作系统提供给应用程序（程序员）使用的接口，可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务</p><figure><img src="/assets/images/image-20221026083536572.png" alt="image-20221026083536572" tabindex="0" loading="lazy"><figcaption>image-20221026083536572</figcaption></figure><p>0</p><h1 id="八、进程" tabindex="-1"><a class="header-anchor" href="#八、进程" aria-hidden="true">#</a> 八、进程</h1><p><code>程序段、数据段、PCB(进程控制块)</code>组成了<code>进程实体</code>。创建进程就是创建进程实体中的PCB，撤销进程就是撤销进程实体中的PCB。</p><blockquote><p>PCB是进程存在的唯一标志</p></blockquote><p><code>进程</code>是进程实体的<mark>运行过程</mark>，是系统进行资源分配和调度的一个独立单位</p><h2 id="_1-进程的组成" tabindex="-1"><a class="header-anchor" href="#_1-进程的组成" aria-hidden="true">#</a> 1. 进程的组成</h2><figure><img src="/assets/images/image-20221026101014079.png" alt="image-20221026101014079" tabindex="0" loading="lazy"><figcaption>image-20221026101014079</figcaption></figure><p>​ <img src="/assets/images/image-20221026101206693.png" alt="image-20221026101206693" loading="lazy"></p><h2 id="_2-进程的组织" tabindex="-1"><a class="header-anchor" href="#_2-进程的组织" aria-hidden="true">#</a> 2. 进程的组织</h2><figure><img src="/assets/images/image-20221026102208884.png" alt="image-20221026102208884" tabindex="0" loading="lazy"><figcaption>image-20221026102208884</figcaption></figure><h2 id="_3-进程的特征" tabindex="-1"><a class="header-anchor" href="#_3-进程的特征" aria-hidden="true">#</a> 3.进程的特征</h2><figure><img src="/assets/images/image-20221026102632508.png" alt="image-20221026102632508" tabindex="0" loading="lazy"><figcaption>image-20221026102632508</figcaption></figure><h1 id="九、进程的状态与转换" tabindex="-1"><a class="header-anchor" href="#九、进程的状态与转换" aria-hidden="true">#</a> 九、进程的状态与转换</h1><h2 id="_1-进程的状态" tabindex="-1"><a class="header-anchor" href="#_1-进程的状态" aria-hidden="true">#</a> 1. 进程的状态</h2><p>三种基本状态</p><figure><img src="/assets/images/image-20221026104622917.png" alt="image-20221026104622917" tabindex="0" loading="lazy"><figcaption>image-20221026104622917</figcaption></figure><figure><img src="/assets/images/image-20221026105335263.png" alt="image-20221026105335263" tabindex="0" loading="lazy"><figcaption>image-20221026105335263</figcaption></figure><h2 id="_2-进程的转换" tabindex="-1"><a class="header-anchor" href="#_2-进程的转换" aria-hidden="true">#</a> 2.进程的转换</h2><figure><img src="/assets/images/image-20221026105932540.png" alt="image-20221026105932540" tabindex="0" loading="lazy"><figcaption>image-20221026105932540</figcaption></figure><h1 id="十、进程控制" tabindex="-1"><a class="header-anchor" href="#十、进程控制" aria-hidden="true">#</a> 十、进程控制</h1><figure><img src="/assets/images/image-20221026153713454.png" alt="image-20221026153713454" tabindex="0" loading="lazy"><figcaption>image-20221026153713454</figcaption></figure><blockquote><p>使用<code>原语</code>实现进程控制。原语的特点就是执行期间<code>不允许中断</code>，这种操作即为<code>原子操作</code></p><p>原语采用<code>关中断指令</code>和<code>开中断指令</code></p></blockquote><p>原语执行在核心态</p><h2 id="_1-原语" tabindex="-1"><a class="header-anchor" href="#_1-原语" aria-hidden="true">#</a> 1.原语</h2><figure><img src="/assets/images/image-20221026154638732.png" alt="image-20221026154638732" tabindex="0" loading="lazy"><figcaption>image-20221026154638732</figcaption></figure><figure><img src="/assets/images/image-20221026154714560.png" alt="image-20221026154714560" tabindex="0" loading="lazy"><figcaption>image-20221026154714560</figcaption></figure><figure><img src="/assets/images/image-20221026155212334.png" alt="image-20221026155212334" tabindex="0" loading="lazy"><figcaption>image-20221026155212334</figcaption></figure><figure><img src="/assets/images/image-20221026155430078.png" alt="image-20221026155430078" tabindex="0" loading="lazy"><figcaption>image-20221026155430078</figcaption></figure><h1 id="十一、进程通信" tabindex="-1"><a class="header-anchor" href="#十一、进程通信" aria-hidden="true">#</a> 十一、进程通信</h1><p>进程通信就是指，进程之间的信息交换</p><p>为了保证安全：<code>一个进程不能直接访问另一个进程的地址空间</code></p><p>但是进程通信又是必须的，操作系统提供了一些方法：</p><ol><li>共享存储</li><li>消息传递</li><li>管道通信</li></ol><h2 id="_1-共享存储" tabindex="-1"><a class="header-anchor" href="#_1-共享存储" aria-hidden="true">#</a> 1.共享存储</h2><p>两个进程对共享空间的访问必须是互斥的</p><p><code>基于数据结构的共享</code>：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢，限制多，是一种低级通信方式</p><p><code>基于存储区的共享</code>：在内存中划分一块共享存储区，数组的形式、存放位置，都是由进程控制，而不是操作系统，相比之下，这种共享方式速度更快，是一种<code>高级通信</code>方式</p><h2 id="_2-管道通信" tabindex="-1"><a class="header-anchor" href="#_2-管道通信" aria-hidden="true">#</a> 2.管道通信</h2><figure><img src="/assets/images/image-20221026170138966.png" alt="image-20221026170138966" tabindex="0" loading="lazy"><figcaption>image-20221026170138966</figcaption></figure><ol><li>管道只能采用<code>半双工通信</code>，某一时刻只能单向传输，如果想要双向传输，则需要设置两个管道。</li><li>各进程要<code>互斥</code>地访问管道</li><li>数据以字符流的形式写入管道，当管道写满时，write()写进程将被阻塞。当管道变空时，此读进程read()将被阻塞</li><li>如果没写满，就不允许读。如果没读完，就不允许写</li><li>数据一旦被读出，就会消失，所以读进程只能有一个。</li></ol><h2 id="_3-消息传递" tabindex="-1"><a class="header-anchor" href="#_3-消息传递" aria-hidden="true">#</a> 3. 消息传递</h2><figure><img src="/assets/images/image-20221026171254351.png" alt="image-20221026171254351" tabindex="0" loading="lazy"><figcaption>image-20221026171254351</figcaption></figure><h1 id="十二、线程-多线程" tabindex="-1"><a class="header-anchor" href="#十二、线程-多线程" aria-hidden="true">#</a> 十二、线程/多线程</h1><h2 id="_1-什么是线程" tabindex="-1"><a class="header-anchor" href="#_1-什么是线程" aria-hidden="true">#</a> 1. 什么是线程</h2><p>传统的进程是程序的执行的最小单位，引入了线程之后，线程是最小的单位，一个进程可以有多个线程</p><figure><img src="/assets/images/image-20221026172128359.png" alt="image-20221026172128359" tabindex="0" loading="lazy"><figcaption>image-20221026172128359</figcaption></figure><p>线程就是<code>轻量级</code>进程。</p><p>进程之间可以并发，进程中的线程也可以并发，进一步提高系统的并发度。使得一个进程内可以处理各种任务。</p><p>引入线程之后，<code>进程</code>只作为<code>除CPU以外的系统资源的分配单元</code>，如打印机，内存地址，都是分配给进程的</p><figure><img src="/assets/images/image-20221026172539697.png" alt="image-20221026172539697" tabindex="0" loading="lazy"><figcaption>image-20221026172539697</figcaption></figure><h2 id="_2-线程的属性" tabindex="-1"><a class="header-anchor" href="#_2-线程的属性" aria-hidden="true">#</a> 2.线程的属性</h2><figure><img src="/assets/images/image-20221026173415914.png" alt="image-20221026173415914" tabindex="0" loading="lazy"><figcaption>image-20221026173415914</figcaption></figure><h2 id="_3-线程的实现方式" tabindex="-1"><a class="header-anchor" href="#_3-线程的实现方式" aria-hidden="true">#</a> 3.线程的实现方式</h2><ol><li>用户级线程</li></ol><figure><img src="/assets/images/image-20221026183005921.png" alt="image-20221026183005921" tabindex="0" loading="lazy"><figcaption>image-20221026183005921</figcaption></figure><ol start="2"><li>内核级线程</li></ol><figure><img src="/assets/images/image-20221026183101346.png" alt="image-20221026183101346" tabindex="0" loading="lazy"><figcaption>image-20221026183101346</figcaption></figure><ol start="3"><li>结合使用</li></ol><figure><img src="/assets/images/image-20221026183225489.png" alt="image-20221026183225489" tabindex="0" loading="lazy"><figcaption>image-20221026183225489</figcaption></figure><h2 id="_4-多线程" tabindex="-1"><a class="header-anchor" href="#_4-多线程" aria-hidden="true">#</a> 4.多线程</h2><p><code>多对一模型：</code></p><figure><img src="/assets/images/image-20221026183455107.png" alt="image-20221026183455107" tabindex="0" loading="lazy"><figcaption>image-20221026183455107</figcaption></figure><p><code>一对一模型：</code></p><figure><img src="/assets/images/image-20221026183603681.png" alt="image-20221026183603681" tabindex="0" loading="lazy"><figcaption>image-20221026183603681</figcaption></figure><p><code>多对多模型：</code></p><figure><img src="/assets/images/image-20221026183702219.png" alt="image-20221026183702219" tabindex="0" loading="lazy"><figcaption>image-20221026183702219</figcaption></figure><h1 id="十三、处理机调度" tabindex="-1"><a class="header-anchor" href="#十三、处理机调度" aria-hidden="true">#</a> 十三、处理机调度</h1><h2 id="_1-调度概念" tabindex="-1"><a class="header-anchor" href="#_1-调度概念" aria-hidden="true">#</a> 1. 调度概念</h2><p>当有一堆任务要处理时，但由于资源有限，没法同时处理，就需要确定某种<code>规则</code>来<code>决定</code>处理这些任务的顺序，这就是调度所研究的问题</p><h2 id="_2-三个层次" tabindex="-1"><a class="header-anchor" href="#_2-三个层次" aria-hidden="true">#</a> 2. 三个层次</h2><figure><img src="/assets/images/image-20221027103236067.png" alt="image-20221027103236067" tabindex="0" loading="lazy"><figcaption>image-20221027103236067</figcaption></figure><h2 id="_3-进程调度时机" tabindex="-1"><a class="header-anchor" href="#_3-进程调度时机" aria-hidden="true">#</a> 3. 进程调度时机</h2><p><code>进程调度</code>（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机</p><p><strong><code>需要进行</code>进程调度与切换的情况：</strong></p><ol><li>当前运行的进程<code>主动放弃</code>处理机： <ol><li>进程正常终止</li><li>运行中发生异常</li><li>进程主动请求阻塞</li></ol></li><li>当前运行的进程<code>被动放弃</code>处理机： <ol><li>进程的时间片用完</li><li>有紧急事件处理</li><li>有更高优先级进程进入就绪队列</li></ol></li></ol><p><strong><code>不能进行</code>进程调度与切换的情况：</strong></p><ol><li>在<code>处理中断的过程中</code>。中断处理复杂，很难做到中断处理过程中进行进程切换</li><li>进程在<code>操作系统内核程序临界区中</code>。</li><li>在<code>原语操作过程中</code>。原子操作不可中断</li></ol><blockquote><p><code>临界资源：</code>一个时间段内只允许一个进程使用的资源。各进程需要互斥访问临界资源</p><p><code>临界区：</code>访问临界资源的那一段代码</p></blockquote><p><code>内核程序临界区</code>：一般是用来访问<code>某种内核数据结构</code>的，比如进程的就绪队列</p><p>当进程要进入就绪队列时，会对就绪队列上锁，等代码执行完成之后，再解锁，此时不能进行调度与切换。此时就绪队列时内核程序临界资源</p><p>但是当进程要进入如打印机类的临界资源，也会上锁，但是也可以进行调度和切换。</p><h2 id="_4-进程调度的方式" tabindex="-1"><a class="header-anchor" href="#_4-进程调度的方式" aria-hidden="true">#</a> 4. 进程调度的方式</h2><p><strong><code>非剥夺调度方式</code></strong></p><p>又称<code>非抢占方式</code>，即只允许进程主动放弃处理机。即是有更紧急的进程，也依然会使用处理结果。</p><p>实现简单，系统开销小，但无法处理紧急任务</p><p><strong><code>剥夺调度方式</code></strong></p><p>又称<code>抢占方式</code>，当一个进程正在使用处理机，如果有更紧急的进程，则立即暂停正在执行的进程，将处理机分配给更紧急的进程</p><p>可以优先处理更紧急的进程，也可以让进程按照时间片轮流执行。适合于分时操作需提供，实时操作系统</p><h2 id="_5-进程切换与过程" tabindex="-1"><a class="header-anchor" href="#_5-进程切换与过程" aria-hidden="true">#</a> 5. 进程切换与过程</h2><p><code>进程调度</code>：指的就是从就绪队列中选中一个要运行的进程，</p><p><code>进程切换</code>：是指一个进程让出处理机，由另一个进程占用处理机的过程</p><p>这个过程主要完成了：</p><ol><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复</li></ol><h2 id="_6-调度算法指标" tabindex="-1"><a class="header-anchor" href="#_6-调度算法指标" aria-hidden="true">#</a> 6. 调度算法指标</h2><h3 id="_1-cpu利用率" tabindex="-1"><a class="header-anchor" href="#_1-cpu利用率" aria-hidden="true">#</a> 1. CPU利用率</h3><p><code>CPU利用率</code>：指CPU“忙碌”的时间占比总时间比例</p><figure><img src="/assets/images/image-20221027110623621.png" alt="image-20221027110623621" tabindex="0" loading="lazy"><figcaption>image-20221027110623621</figcaption></figure><figure><img src="/assets/images/image-20221027110738925.png" alt="image-20221027110738925" tabindex="0" loading="lazy"><figcaption>image-20221027110738925</figcaption></figure><h3 id="_2-系统吞吐量" tabindex="-1"><a class="header-anchor" href="#_2-系统吞吐量" aria-hidden="true">#</a> 2. 系统吞吐量</h3><p>单位时间完成作业的数量</p><p><code>系统吞吐量=总完成作业/总花费时间</code></p><figure><img src="/assets/images/image-20221027110932387.png" alt="image-20221027110932387" tabindex="0" loading="lazy"><figcaption>image-20221027110932387</figcaption></figure><h3 id="_3-周转时间" tabindex="-1"><a class="header-anchor" href="#_3-周转时间" aria-hidden="true">#</a> 3. 周转时间</h3><p>是指从<code>作业被提交给系统开始，到作业完成为止</code>的这段时间间隔</p><p><code>周转时间</code>=作业完成时间 - 作业提交时间</p><p><code>平均周转时间=</code>各作业周转时间之和 / 作业数</p><p><code>带权周转时间=</code>作业周转时间 / 作业实际运行的时间 = 作业完成时间 - 作业提交时间 / 作业实际运行时间</p><p><code>平均带权周转事件=</code>各作业带权周转时间之和 / 作业数</p><h3 id="_4-等待时间" tabindex="-1"><a class="header-anchor" href="#_4-等待时间" aria-hidden="true">#</a> 4.等待时间</h3><p>是指进程或作业<code>处于等待处理机状态时间之和</code>，等待时间越长，满意度越低</p><h3 id="_5-响应时间" tabindex="-1"><a class="header-anchor" href="#_5-响应时间" aria-hidden="true">#</a> 5.响应时间</h3><p>是指用户<code>提交请求</code>到<code>首次产生响应</code>所用的时间</p><h1 id="十四、调度算法" tabindex="-1"><a class="header-anchor" href="#十四、调度算法" aria-hidden="true">#</a> 十四、调度算法</h1><p>后三种适合于<code>交互式系统</code></p><h2 id="_1-fcfs" tabindex="-1"><a class="header-anchor" href="#_1-fcfs" aria-hidden="true">#</a> 1. FCFS</h2><blockquote><p><strong>先来先服务FCFS</strong></p></blockquote><p><code>算法思想：</code>主要从公平角度思考，类似排队买东西</p><p><code>算法规则：</code>按照作业/进程到达的先后顺序进行服务</p><p><code>用于作业/进程调度</code>：用于作业调度时：考虑哪个作业先到达后备队列。用于进程调度时：考虑哪个进程先到达就绪队列</p><p><code>是否可抢占</code>：非抢占式算法</p><p><code>优缺点：</code>优点：公平，算法实现简单</p><p>​ 缺点：对短作业不利，排在长作业之后，需要等待很长时间</p><p><code>是否会导致饥饿：</code>不会</p><figure><img src="/assets/images/image-20221027113930687.png" alt="image-20221027113930687" tabindex="0" loading="lazy"><figcaption>image-20221027113930687</figcaption></figure><h2 id="_2-sjf" tabindex="-1"><a class="header-anchor" href="#_2-sjf" aria-hidden="true">#</a> 2. SJF</h2><blockquote><p>短作业优先SJF</p></blockquote><p><code>算法思想：</code>追求最少的平均等待时间，最少的平均</p><p><code>算法规则：</code>最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）</p><p><code>用于作业/进程调度：</code>两个都可使用，用于进程调度时称为：“短进程优先算法SPF”</p><p><code>是否可抢占：</code>SJF和SPF是<code>非抢占式</code>，但也有抢占版本：<code>最短剩余时间优先算法SRTN</code></p><p><code>优缺点</code>：优点：最短的平均等待时间。缺点：对短作业有利，对长作业不利</p><p><code>是否会导致饥饿</code>：会</p><figure><img src="/assets/images/image-20221028095109173.png" alt="image-20221028095109173" tabindex="0" loading="lazy"><figcaption>image-20221028095109173</figcaption></figure><figure><img src="/assets/images/image-20221028095806460.png" alt="image-20221028095806460" tabindex="0" loading="lazy"><figcaption>image-20221028095806460</figcaption></figure><h2 id="_3-hrrn" tabindex="-1"><a class="header-anchor" href="#_3-hrrn" aria-hidden="true">#</a> 3. HRRN</h2><blockquote><p><strong>高响应比优先算法</strong></p></blockquote><p><code>算法思想：</code>要综合考虑作业/进程的等待时间和要求服务的时间</p><p><code>算法规则：</code>每次调度之前计算各个作业/进程的<code>响应比</code>。选择响应比最高的作业/进程为其服务</p><p>​ <code>响应比=</code>等待时间+要求服务时间 / 要求服务时间</p><p><code>用于作业/进程调度：</code>都可</p><p><code>是否抢占式：</code>非抢占式</p><p><code>优缺点：</code>综合考虑了等待时间和要求服务时间</p><p><code>是否会饥饿：</code>不会</p><figure><img src="/assets/images/image-20221028102950354.png" alt="image-20221028102950354" tabindex="0" loading="lazy"><figcaption>image-20221028102950354</figcaption></figure><h2 id="_4-rr" tabindex="-1"><a class="header-anchor" href="#_4-rr" aria-hidden="true">#</a> 4.RR</h2><p>以下三种适合<code>交互式系统</code></p><blockquote><p><strong>时间片轮转算法</strong></p></blockquote><p><code>算法思想：</code>公平的，轮流的，为各个进程提供服务，让每个进程在一定时间间隔内都可以得到响应</p><p><code>算法规则：</code>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，若进程未在一个时间片内完成，则失去处理机，放到队尾重新排队</p><p><code>用于作业/进程调度：</code>进程调度。只有作业放入进程之后，才可能被分配到时间片</p><p><code>是否抢占式：</code>是抢占式。由时钟装置发出时钟中断通知CPU时间片已到</p><p><code>优缺点：</code>公平，响应快，适用于分时操作系统。缺点：开销大，不区分任务的紧急程度</p><p><code>是否会饥饿：</code>不会</p><figure><img src="/assets/images/image-20221028104735954.png" alt="image-20221028104735954" tabindex="0" loading="lazy"><figcaption>image-20221028104735954</figcaption></figure><figure><img src="/assets/images/image-20221028105143140.png" alt="image-20221028105143140" tabindex="0" loading="lazy"><figcaption>image-20221028105143140</figcaption></figure><figure><img src="/assets/images/image-20221028105106093.png" alt="image-20221028105106093" tabindex="0" loading="lazy"><figcaption>image-20221028105106093</figcaption></figure><p><code>时间片</code>不能太大，太大就会变为<code>先来先服务</code>算法，会增大进程响应时间</p><h2 id="_5-优先级调度算法" tabindex="-1"><a class="header-anchor" href="#_5-优先级调度算法" aria-hidden="true">#</a> 5. 优先级调度算法</h2><p><code>算法思想：</code>根据任务的紧急程度来决定处理顺序</p><p><code>算法规则：</code>每个作业/进程都有各自的优先级，调度时选择优先级最高的</p><p><code>用于作业/进程调度：</code>都可使用，还可以使用在IO调度中</p><p><code>是否抢占式：</code>抢占式，非抢占式都有。</p><p><code>优缺点：</code>区分紧急程度，重要程度。缺点：如果有很多高优先级进程，则可能导致饥饿</p><p><code>是否会饥饿：</code>会</p><figure><img src="/assets/images/image-20221029180129648.png" alt="image-20221029180129648" tabindex="0" loading="lazy"><figcaption>image-20221029180129648</figcaption></figure><figure><img src="/assets/images/image-20221029181010828.png" alt="image-20221029181010828" tabindex="0" loading="lazy"><figcaption>image-20221029181010828</figcaption></figure><h2 id="_6-多级反馈队列调度" tabindex="-1"><a class="header-anchor" href="#_6-多级反馈队列调度" aria-hidden="true">#</a> 6. 多级反馈队列调度</h2><p><code>算法思想：</code>对上述其他算法进行折中权衡</p><p><code>算法规则：</code>1.设置多级就绪队列，各级优先队列优先级从高到低，时间片从小到大。2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</p><p><code>用于作业/进程调度：</code>用于进程调度</p><p><code>是否抢占：</code>抢占式算法。在k级队列中进程运行过程中，若更上级的队列中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</p><p><code>优缺点：</code>对各类型进程相对公平（FCFS优点）；每个新进程都可以很快得到响应（RR优点）；短进程只用较少的事件即可完成（SJF优点）；可灵活地调整各类进程的偏好程度</p><p><code>是否导致饥饿</code>：会</p><figure><img src="/assets/images/image-20221029191652803.png" alt="image-20221029191652803" tabindex="0" loading="lazy"><figcaption>image-20221029191652803</figcaption></figure><h1 id="十五、进程同步-互斥" tabindex="-1"><a class="header-anchor" href="#十五、进程同步-互斥" aria-hidden="true">#</a> 十五、进程同步/互斥</h1><h2 id="_1-进程同步" tabindex="-1"><a class="header-anchor" href="#_1-进程同步" aria-hidden="true">#</a> 1.进程同步</h2><p>并发具有异步性，有时需要同步处理这些异步问题。</p><p>各进程之间推进需要一定的顺序。</p><h2 id="_2-进程互斥" tabindex="-1"><a class="header-anchor" href="#_2-进程互斥" aria-hidden="true">#</a> 2.进程互斥</h2><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要以下原则：</p><ol><li>空闲让进。临界区空闲时，可以允许一个请求进入临界区的程序立即进入临界区</li><li>忙则等待。当已有进程进入临界区，其他试图进入临界区的进程必须等待</li><li>有限等待。对请求访问的进程，应保证能在有限时间内进入临界区</li><li>让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</li></ol><h2 id="_3-进程互斥的软件实现" tabindex="-1"><a class="header-anchor" href="#_3-进程互斥的软件实现" aria-hidden="true">#</a> 3.进程互斥的软件实现</h2><h3 id="_1-单标签法" tabindex="-1"><a class="header-anchor" href="#_1-单标签法" aria-hidden="true">#</a> 1. 单标签法</h3><p><code>算法思想：</code>两个进程在使用完临界区之后，会把临界区 的使用权限交给另一个进程，也就是每个进程进入临界区的权限只能被另一个进程赋予</p><figure><img src="/assets/images/image-20221030112509598.png" alt="image-20221030112509598" tabindex="0" loading="lazy"><figcaption>image-20221030112509598</figcaption></figure><h3 id="_2-双标志检查法" tabindex="-1"><a class="header-anchor" href="#_2-双标志检查法" aria-hidden="true">#</a> 2. 双标志检查法</h3><figure><img src="/assets/images/image-20221030114240298.png" alt="image-20221030114240298" tabindex="0" loading="lazy"><figcaption>image-20221030114240298</figcaption></figure><h3 id="_3-双标志后检查法" tabindex="-1"><a class="header-anchor" href="#_3-双标志后检查法" aria-hidden="true">#</a> 3.双标志后检查法</h3><figure><img src="/assets/images/image-20221030114407558.png" alt="image-20221030114407558" tabindex="0" loading="lazy"><figcaption>image-20221030114407558</figcaption></figure><h3 id="_4-peterson算法" tabindex="-1"><a class="header-anchor" href="#_4-peterson算法" aria-hidden="true">#</a> 4.Peterson算法</h3><figure><img src="/assets/images/image-20221030114927003.png" alt="image-20221030114927003" tabindex="0" loading="lazy"><figcaption>image-20221030114927003</figcaption></figure><p>Peterson算法用软件解决了进程互斥问题，遵循了<code>空闲让进，忙则等待，有限等待 三个原则。</code>但是没有遵循<code>让权等待</code></p><h2 id="_4-进程互斥的硬件实现" tabindex="-1"><a class="header-anchor" href="#_4-进程互斥的硬件实现" aria-hidden="true">#</a> 4.进程互斥的硬件实现</h2><h3 id="_1-中断屏蔽方法" tabindex="-1"><a class="header-anchor" href="#_1-中断屏蔽方法" aria-hidden="true">#</a> 1. 中断屏蔽方法</h3><figure><img src="/assets/images/image-20221030163311867.png" alt="image-20221030163311867" tabindex="0" loading="lazy"><figcaption>image-20221030163311867</figcaption></figure><h3 id="_2-testandset指令" tabindex="-1"><a class="header-anchor" href="#_2-testandset指令" aria-hidden="true">#</a> 2.TestAndSet指令</h3><figure><img src="/assets/images/image-20221030164305503.png" alt="image-20221030164305503" tabindex="0" loading="lazy"><figcaption>image-20221030164305503</figcaption></figure><h3 id="_3-swap指令" tabindex="-1"><a class="header-anchor" href="#_3-swap指令" aria-hidden="true">#</a> 3.Swap指令</h3><figure><img src="/assets/images/image-20221030164618214.png" alt="image-20221030164618214" tabindex="0" loading="lazy"><figcaption>image-20221030164618214</figcaption></figure><h1 id="十六、信号量机制" tabindex="-1"><a class="header-anchor" href="#十六、信号量机制" aria-hidden="true">#</a> 十六、信号量机制</h1><p>用户进程可以通过使用操作系统提供的<code>一对原语</code>来对<code>信号量</code>进行操作，从而很方便的实现了进程互斥、进程同步</p><p><code>信号量</code>其实就是一个变量，可以用<code>一个信号量表示系统中某种资源的数量</code></p><p><code>一对原语：wait(S)</code>原语和<code>signal(S)</code>原语，可以把原语理解为自己写的函数，函数名为wait和signal，括号里的<code>信号量S</code>其实就是函数调用时传入的一个参数。</p><p><code>wait、signal</code>原语常简称为<code>P、V操作</code>。因此，做题时常把wait(S和signal(S)两个操作写为<code>P(S)、V(S)</code></p><h2 id="_1-整形信号量" tabindex="-1"><a class="header-anchor" href="#_1-整形信号量" aria-hidden="true">#</a> 1. 整形信号量</h2><figure><img src="/assets/images/image-20221030184919026.png" alt="image-20221030184919026" tabindex="0" loading="lazy"><figcaption>image-20221030184919026</figcaption></figure><h2 id="_2-记录型信号量" tabindex="-1"><a class="header-anchor" href="#_2-记录型信号量" aria-hidden="true">#</a> 2. 记录型信号量</h2><figure><img src="/assets/images/image-20221030191334035.png" alt="image-20221030191334035" tabindex="0" loading="lazy"><figcaption>image-20221030191334035</figcaption></figure><h2 id="_3-信号量机制实现进程互斥" tabindex="-1"><a class="header-anchor" href="#_3-信号量机制实现进程互斥" aria-hidden="true">#</a> 3. 信号量机制实现进程互斥</h2><figure><img src="/assets/images/image-20221030192021395.png" alt="image-20221030192021395" tabindex="0" loading="lazy"><figcaption>image-20221030192021395</figcaption></figure><h2 id="_4-信号量机制实现进程同步" tabindex="-1"><a class="header-anchor" href="#_4-信号量机制实现进程同步" aria-hidden="true">#</a> 4. 信号量机制实现进程同步</h2><figure><img src="/assets/images/image-20221030201007592.png" alt="image-20221030201007592" tabindex="0" loading="lazy"><figcaption>image-20221030201007592</figcaption></figure><h2 id="_5-实现进程的同步关系" tabindex="-1"><a class="header-anchor" href="#_5-实现进程的同步关系" aria-hidden="true">#</a> 5.实现进程的同步关系</h2><figure><img src="/assets/images/image-20221030201357910.png" alt="image-20221030201357910" tabindex="0" loading="lazy"><figcaption>image-20221030201357910</figcaption></figure><h1 id="十七、生产者消费者" tabindex="-1"><a class="header-anchor" href="#十七、生产者消费者" aria-hidden="true">#</a> 十七、生产者消费者</h1><p>系统中有一组生产者进程和消费者进程，生产者进程每次生产一个数据放入缓存区，消费者进程每次从缓冲区中取出一个数据并使用</p><p>生产者、消费者共享一个初始为空、大小为n的缓冲区</p><p>只有缓冲区没满时，生产者才能把数据放入缓冲区，否则必须等待。只有缓冲区不空时，消费者才能从中取出产品，否则必须等待</p><p>缓冲区是<code>临界资源</code>，各进程必须互斥的访问</p><figure><img src="/assets/images/image-20221030202940683.png" alt="image-20221030202940683" tabindex="0" loading="lazy"><figcaption>image-20221030202940683</figcaption></figure><h2 id="_1-多生产者多消费者" tabindex="-1"><a class="header-anchor" href="#_1-多生产者多消费者" aria-hidden="true">#</a> 1. 多生产者多消费者</h2><figure><img src="/assets/images/image-20221031091429087.png" alt="image-20221031091429087" tabindex="0" loading="lazy"><figcaption>image-20221031091429087</figcaption></figure><figure><img src="/assets/images/image-20221031091501823.png" alt="image-20221031091501823" tabindex="0" loading="lazy"><figcaption>image-20221031091501823</figcaption></figure><p>如果缓冲区大小大于1，就必须专门放置一个互斥信号量mutex来保证互斥访问缓冲区</p><h1 id="十八、吸烟者问题" tabindex="-1"><a class="header-anchor" href="#十八、吸烟者问题" aria-hidden="true">#</a> 十八、吸烟者问题</h1><figure><img src="/assets/images/image-20221031092527012.png" alt="image-20221031092527012" tabindex="0" loading="lazy"><figcaption>image-20221031092527012</figcaption></figure><p>如何实现进程同步和进程互斥</p><figure><img src="/assets/images/image-20221031093300160.png" alt="image-20221031093300160" tabindex="0" loading="lazy"><figcaption>image-20221031093300160</figcaption></figure><h1 id="十九、读者、写者" tabindex="-1"><a class="header-anchor" href="#十九、读者、写者" aria-hidden="true">#</a> 十九、读者、写者</h1><figure><img src="/assets/images/image-20221031093738934.png" alt="image-20221031093738934" tabindex="0" loading="lazy"><figcaption>image-20221031093738934</figcaption></figure><figure><img src="/assets/images/image-20221031094938348.png" alt="image-20221031094938348" tabindex="0" loading="lazy"><figcaption>image-20221031094938348</figcaption></figure><figure><img src="/assets/images/image-20221031095025917.png" alt="image-20221031095025917" tabindex="0" loading="lazy"><figcaption>image-20221031095025917</figcaption></figure><h1 id="二十、哲学家进餐问题" tabindex="-1"><a class="header-anchor" href="#二十、哲学家进餐问题" aria-hidden="true">#</a> 二十、哲学家进餐问题</h1><figure><img src="/assets/images/image-20221031095631870.png" alt="image-20221031095631870" tabindex="0" loading="lazy"><figcaption>image-20221031095631870</figcaption></figure><p><mark>这个方法不可取</mark></p><p>解决进程死锁</p><figure><img src="/assets/images/image-20221031100721047.png" alt="image-20221031100721047" tabindex="0" loading="lazy"><figcaption>image-20221031100721047</figcaption></figure><h1 id="二十一、管程" tabindex="-1"><a class="header-anchor" href="#二十一、管程" aria-hidden="true">#</a> 二十一、管程</h1><p>为了解决PV操作的复杂，使用管程来简化这些操作</p><h2 id="_1-管程解决生产者消费者问题" tabindex="-1"><a class="header-anchor" href="#_1-管程解决生产者消费者问题" aria-hidden="true">#</a> 1.管程解决生产者消费者问题</h2><figure><img src="/assets/images/image-20221031102027887.png" alt="image-20221031102027887" tabindex="0" loading="lazy"><figcaption>image-20221031102027887</figcaption></figure><figure><img src="/assets/images/image-20221031102327873.png" alt="image-20221031102327873" tabindex="0" loading="lazy"><figcaption>image-20221031102327873</figcaption></figure><figure><img src="/assets/images/image-20221031102511010.png" alt="image-20221031102511010" tabindex="0" loading="lazy"><figcaption>image-20221031102511010</figcaption></figure><h1 id="二十二、死锁" tabindex="-1"><a class="header-anchor" href="#二十二、死锁" aria-hidden="true">#</a> 二十二、死锁</h1><h2 id="_1-死锁、饥饿、死循环" tabindex="-1"><a class="header-anchor" href="#_1-死锁、饥饿、死循环" aria-hidden="true">#</a> 1.死锁、饥饿、死循环</h2><p><code>死锁：</code>各进程互相等待对方手里的资源，导致各进程互相阻塞，无法向前推进的现象</p><p><code>饥饿：</code>长期得不到想要的资源，某进程无法向前推进的现象，。</p><p><code>死循环：</code>跳不出某个循环，有时是bug导致，有时是故意设置</p><h2 id="_2-死锁发生的条件" tabindex="-1"><a class="header-anchor" href="#_2-死锁发生的条件" aria-hidden="true">#</a> 2.死锁发生的条件</h2><p>必须满足以下四个条件：</p><p><code>互斥条件：</code>只有对必须互斥使用的资源的争抢才会导致死锁</p><p><code>不剥夺条件：</code>进程所获得的资源在未使用完之前，不能 由其他进程夺走资源，只能主动释放</p><p><code>请求和保持条件：</code>进程已经保持了一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又不释放自己的资源</p><p><code>循环等待条件：</code>链中的每一个进程已获得的资源同时被下一个进程所请求</p><p><code>注意：</code>发生死锁时一定有循环等待，但是发生循环等待时未必死锁</p><h2 id="_3-死锁的处理策略" tabindex="-1"><a class="header-anchor" href="#_3-死锁的处理策略" aria-hidden="true">#</a> 3.死锁的处理策略</h2><ol><li>预防死锁。破坏死锁产生的四个必要条件中的一个</li><li>避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）</li><li>死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁</li></ol><h2 id="_4-预防死锁" tabindex="-1"><a class="header-anchor" href="#_4-预防死锁" aria-hidden="true">#</a> 4.预防死锁</h2><h3 id="_1-破坏互斥条件" tabindex="-1"><a class="header-anchor" href="#_1-破坏互斥条件" aria-hidden="true">#</a> 1.破坏互斥条件</h3><p>把互斥的资源改为允许共享使用的资源。如<code>SPOOLing技术</code></p><p>缺点：不是所有的资源都可以改造成可共享使用的资源</p><h3 id="_2-破坏不剥夺条件" tabindex="-1"><a class="header-anchor" href="#_2-破坏不剥夺条件" aria-hidden="true">#</a> 2.破坏不剥夺条件</h3><ol><li>当某个进程请求新的资源得不到时，必须立刻释放已拥有的资源，等待再重新申请。也就是说，即是某些资源尚未使用完，也要主动释放。</li><li>当某个进程需要的资源被其他进程占用时，可以由操作系统协助，将想要的资源强行剥夺。</li></ol><p>缺点：实现复杂。释放资源可能导致前一段工作失效</p><h3 id="_3-破坏请求和保持条件" tabindex="-1"><a class="header-anchor" href="#_3-破坏请求和保持条件" aria-hidden="true">#</a> 3.破坏请求和保持条件</h3><p>可以采用静态分配方法，即进程在运行前，申请完它所需要的全部资源，在资源未完成之前，不让进程运行</p><p>缺点：资源利用率低，可能导致饥饿</p><h3 id="_4-破坏循环等待条件" tabindex="-1"><a class="header-anchor" href="#_4-破坏循环等待条件" aria-hidden="true">#</a> 4.破坏循环等待条件</h3><p>可采用<code>顺序资源分配法</code>。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源。</p><p>一个进程只有已占有小编号的资源时，才有资格申请大编号的资源。</p><p>缺点：不方便增加新的设备，需要重新分配所有的编号。进程实际使用资源的顺序可能和序号递增顺序不一致，会导致资源浪费。必须按规定次序申请资源，用户编程麻烦</p><h2 id="_5-避免死锁" tabindex="-1"><a class="header-anchor" href="#_5-避免死锁" aria-hidden="true">#</a> 5.避免死锁</h2><h3 id="_1-什么是安全序列" tabindex="-1"><a class="header-anchor" href="#_1-什么是安全序列" aria-hidden="true">#</a> 1. 什么是安全序列</h3><p><code>安全序列：</code>就是指如果系统按照一种序列分配资源，则每个进程都能顺利完成。只要找到一个安全序列，系统就是<code>安全状态</code>。安全序列可以有多个。</p><p>如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了<code>不安全状态</code>。</p><p>如果系统处于<code>安全状态</code>，就<code>一定不发发生死锁</code>，如果系统进入<code>不安全状态</code>，就<code>可能发生死锁</code>。</p><p>但发生死锁时，一定是在不安全状态下。</p><p><code>银行家算法：</code>在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。</p><h3 id="_2-银行家算法" tabindex="-1"><a class="header-anchor" href="#_2-银行家算法" aria-hidden="true">#</a> 2.银行家算法</h3><figure><img src="/assets/images/image-20221031164939094.png" alt="image-20221031164939094" tabindex="0" loading="lazy"><figcaption>image-20221031164939094</figcaption></figure><figure><img src="/assets/images/image-20221031165025486.png" alt="image-20221031165025486" tabindex="0" loading="lazy"><figcaption>image-20221031165025486</figcaption></figure><h2 id="_6-死锁的检测和解除" tabindex="-1"><a class="header-anchor" href="#_6-死锁的检测和解除" aria-hidden="true">#</a> 6.死锁的检测和解除</h2><h3 id="_1-死锁的检测" tabindex="-1"><a class="header-anchor" href="#_1-死锁的检测" aria-hidden="true">#</a> 1.死锁的检测</h3><p>为了能对系统是否已经发生了死锁进行检测：</p><ol><li>用<code>某种数据结构</code>来保存资源的请求和分配信息。</li><li>提供<code>一种算法</code>，利用上述信息来检测系统是否已经进入死锁状态</li></ol><figure><img src="/assets/images/image-20221031170701813.png" alt="image-20221031170701813" tabindex="0" loading="lazy"><figcaption>image-20221031170701813</figcaption></figure><p>如果系统中剩余的可用资源数足够<code>满足进程的需求</code>，那么这个进程暂时是不会阻塞的，可以顺利地执行下去，如果这个进程执行结束了，把资源归还给系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去</p><figure><img src="/assets/images/image-20221031174044568.png" alt="image-20221031174044568" tabindex="0" loading="lazy"><figcaption>image-20221031174044568</figcaption></figure><p>如果不能消除<code>所有边</code>，那么就是发生了死锁。上面的图就是一个死锁</p><p>检测死锁的算法：</p><ol><li>在资源分配图中，找出既不阻塞又不是孤点的进程Pi，就是可以消掉边的点，消去它的请求边和分配边，使之成为孤立的节点。在上图不是死锁的图中，P1满足，把P1的边消掉</li><li>进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程变为非阻塞进程。</li><li>如果消去所有的边，则称该图是<code>可完全简化的</code></li></ol><p><code>死锁定理：</code>如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁</p><h3 id="_2-解除死锁" tabindex="-1"><a class="header-anchor" href="#_2-解除死锁" aria-hidden="true">#</a> 2.解除死锁</h3><ol><li><code>资源剥夺法。</code>挂起某些死锁进程，暂时放在外存，并剥夺它的资源，将这些资源分配给其他的死锁进程。</li><li><code>撤销进程法。</code>强制撤销部分进程，甚至全部进程。并剥夺这些进程的资源。实现简单，代价大，会让已经快结束的进程功亏一篑</li><li><code>进程回退法。</code>让一个或多个进程回退到足以避免死锁的地步，这就要求系统要记录进程的历史信息，设置还原点</li></ol><h1 id="二十三、内存" tabindex="-1"><a class="header-anchor" href="#二十三、内存" aria-hidden="true">#</a> 二十三、内存</h1><blockquote><p>操作系统是系统资源的管理者，当然也需要对内存进行管理，需要管理的有：</p><ol><li>负责<code>内存空间的分配与回收</code></li><li>提供从逻辑上<code>对内存空间进行扩充</code></li><li>提供<code>地址转换功能</code>，负责程序的逻辑地址与物理地址的转换</li><li>提供<code>内存保护</code>功能，保证各进程在各自存储空间内运行，互不干扰</li></ol></blockquote><p>在内存中编译时，只关心<code>相对位置</code>，实际放入内存时，再想办法根据起始位置得到<code>绝对地址</code></p><p><code>相对地址</code>又称<code>逻辑地址</code>，<code>绝对地址</code>又称<code>物理地址</code></p><figure><img src="/assets/images/image-20221031193032345.png" alt="image-20221031193032345" tabindex="0" loading="lazy"><figcaption>image-20221031193032345</figcaption></figure><h2 id="_1-装入方式" tabindex="-1"><a class="header-anchor" href="#_1-装入方式" aria-hidden="true">#</a> 1.装入方式</h2><p>装入的三种方式（用三种不同的方法完成<code>逻辑地址 到 物理地址 的转换</code>）：</p><ol><li>绝对装入 在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存</li><li>静态重定位 <img src="/assets/images/image-20221031192754718.png" alt="image-20221031192754718" loading="lazy"></li><li>动态重定位 <img src="/assets/images/image-20221031192929747.png" alt="image-20221031192929747" loading="lazy"></li></ol><h2 id="_2-链接方式" tabindex="-1"><a class="header-anchor" href="#_2-链接方式" aria-hidden="true">#</a> 2.链接方式</h2><figure><img src="/assets/images/image-20221031193340739.png" alt="image-20221031193340739" tabindex="0" loading="lazy"><figcaption>image-20221031193340739</figcaption></figure><h2 id="_3-内存保护" tabindex="-1"><a class="header-anchor" href="#_3-内存保护" aria-hidden="true">#</a> 3.内存保护</h2><figure><img src="/assets/images/image-20221031195146659.png" alt="image-20221031195146659" tabindex="0" loading="lazy"><figcaption>image-20221031195146659</figcaption></figure><figure><img src="/assets/images/image-20221031195256953.png" alt="image-20221031195256953" tabindex="0" loading="lazy"><figcaption>image-20221031195256953</figcaption></figure><h2 id="_4-覆盖与交换" tabindex="-1"><a class="header-anchor" href="#_4-覆盖与交换" aria-hidden="true">#</a> 4.覆盖与交换</h2><p>计算机内存较小，无法把一个大型软件全部运行</p><p>之后引入<code>覆盖技术</code>，用来<code>解决“程序大小超过物理内存总和”</code>的问题</p><p>覆盖技术思想：将<code>程序分为多个段</code>，常用的段常驻内存，不常用的段在需要时调入内存</p><p>内存中分为一个<code>“固定区”</code>，和若干个<code>“覆盖区”</code></p><p>需要常驻内存的段放在<code>固定区</code>，调入后就不再调出，除非运行结束</p><p>不常用的段放在<code>“覆盖区”</code>，需要用时调入内存，用不到时调出内存</p><figure><img src="/assets/images/image-20221031201127995.png" alt="image-20221031201127995" tabindex="0" loading="lazy"><figcaption>image-20221031201127995</figcaption></figure><p><code>交换技术设计思想</code>：内存空间紧张时，系统将内存中某些进程暂时调出外存，把外存中某些已具备运行条件的进程换入内存</p><figure><img src="/assets/images/image-20221031202417496.png" alt="image-20221031202417496" tabindex="0" loading="lazy"><figcaption>image-20221031202417496</figcaption></figure><figure><img src="/assets/images/image-20221031202730509.png" alt="image-20221031202730509" tabindex="0" loading="lazy"><figcaption>image-20221031202730509</figcaption></figure><figure><img src="/assets/images/image-20221031203139203.png" alt="image-20221031203139203" tabindex="0" loading="lazy"><figcaption>image-20221031203139203</figcaption></figure><h2 id="_5-内存空间的分配与回收" tabindex="-1"><a class="header-anchor" href="#_5-内存空间的分配与回收" aria-hidden="true">#</a> 5.内存空间的分配与回收</h2><p><code>内部碎片：</code>分配个某进程的内存区域中，如果有些部分没有用上</p><p><code>外部碎片：</code>是指内存中的某些空闲分区由于太小而难以利用</p><h3 id="_1-连续分配管理方式" tabindex="-1"><a class="header-anchor" href="#_1-连续分配管理方式" aria-hidden="true">#</a> （1）连续分配管理方式</h3><p>为用户分配一段连续的内存空间</p><blockquote><p><strong>单一连续分配</strong></p></blockquote><p>在单一连续分配方式中，内存被分为<code>系统区</code>和<code>用户区</code>。系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用于进程相关数据。</p><p>单一连续分配<code>只能有一道用户程序</code>，用户程序独占整个用户区空间。</p><p>有点：实现简单，无外部碎片；可以采用覆盖技术扩充内存。不一定需要采取内存保护</p><p>用于早期的计算机系统</p><p>缺点：只能用于单用户，单任务的操作系统中，有<code>内部碎片</code>，存储器 利用率极低。</p><p><code>内部碎片：</code>分配给某进程的内存区域中，有些部分没有用上，就是内部碎片</p><figure><img src="/assets/images/image-20221101111712854.png" alt="image-20221101111712854" tabindex="0" loading="lazy"><figcaption>image-20221101111712854</figcaption></figure><blockquote><p><strong>固定分区分配</strong></p></blockquote><p>20世纪60年代，出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会互相干扰，于是将整个<code>用户空间</code>划分为<code>若干个固定大小的分区</code>，在<code>每个分区中只装入一道作业</code>。</p><figure><img src="/assets/images/image-20221101111834019.png" alt="image-20221101111834019" tabindex="0" loading="lazy"><figcaption>image-20221101111834019</figcaption></figure><figure><img src="/assets/images/image-20221101111859551.png" alt="image-20221101111859551" tabindex="0" loading="lazy"><figcaption>image-20221101111859551</figcaption></figure><p>分区大小相等：缺乏灵活性，但是很<code>适合用于一台计算机控制多个相同对象的场合</code></p><p>分区大小不等：增加了灵活性，可以满足不同大小的进程需求。</p><p>操作系统需要建立一个数据结构&gt;<code>分区说明表</code>，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列，每个表项包括对应分区的<code>大小、起始地址、状态</code>，</p><figure><img src="/assets/images/image-20221102090746058.png" alt="image-20221102090746058" tabindex="0" loading="lazy"><figcaption>image-20221102090746058</figcaption></figure><p>当用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的，未分配的分区，将分区分配给该程序，然后状态改为：已分配</p><p>优点：实现简单，<code>无外部碎片</code></p><p>缺点：1.程序太大时，需要采用覆盖技术，覆盖技术又会降低性能。2.会产生内部碎片，内存利用率低</p><blockquote><p><strong>动态分区分配</strong></p></blockquote><p>又称<code>可变分区分配</code>，这种分配方式，<code>不会预先划分内存区</code>，在程序装入内存时，根据<code>进程的大小动态的创建分区</code>，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。</p><figure><img src="/assets/images/image-20221102091650516.png" alt="image-20221102091650516" tabindex="0" loading="lazy"><figcaption>image-20221102091650516</figcaption></figure><ol><li><p>系统要用什么样的数据结构记录内存的使用情况 两种数据结构：<code>空闲分区表</code>和<code>空闲分区链</code><img src="/assets/images/image-20221102092150308.png" alt="image-20221102092150308" loading="lazy"><img src="/assets/images/image-20221102092242912.png" alt="image-20221102092242912" loading="lazy"></p></li><li><p>当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配</p><figure><img src="/assets/images/image-20221102095610234.png" alt="image-20221102095610234" tabindex="0" loading="lazy"><figcaption>image-20221102095610234</figcaption></figure><p>（1）首次适应算法 <code>算法思想：</code>每次都从低地址开始查找，找到第一个能满足大小的空闲分区 <code>实现方法：</code>空闲分区表以<code>地址递增的次序排列</code>，每次分配内存时，按顺序查找空闲分区链，找到第一个满足的空闲分区</p><p>（2）最佳适应算法</p><p>​ <code>算法思想：</code>为了在大进程来到的时候，有大片空闲分区，所以优先使用最小的空闲区</p><p>​ <code>实现：</code>空闲分区表按<code>容量递增次序排列</code>，每次分配内存时，按顺序查找空闲分区表或链，找到的第一个空闲分区，就是最小的满足进程的分区</p><p>（3）最坏适应算法</p><p>又称<code>最大适应算法</code></p><p>​ <code>算法思想：</code>为了解决最佳适应算法遗留的问题：留下太多难以利用的小碎片。在每次分配时优先使用最大的连续空闲区，这样留下的空闲分区不会太小</p><p>​ <code>实现：</code>按<code>容量递减次序排序</code>，按顺序查找，找到大小满足的第一个空闲分区 ​ <code>缺点：</code>没有给大进程留足够的空闲分区</p><p>（4）邻近适应算法</p><p>​ <code>算法思想：</code>每次查找都从上次查找结束的位置开始检索。解决了每次从链头查找的开销</p><p>​ <code>实现：</code>空闲分区以<code>地址递增循环排列</code>，形成一个循环链表，每次分配内存时，从上次查找结束的位置开始查找空闲分区链，找到第一个能满足的空闲分区</p></li><li><p>如何进行分区的分配和回收操作 <img src="/assets/images/image-20221102092616982.png" alt="image-20221102092616982" loading="lazy"> (1)当有一个4MB的进程需要分配，有两种方式： 分给分区1：<img src="/assets/images/image-20221102092842674.png" alt="image-20221102092842674" loading="lazy"> 分给分区3：<img src="/assets/images/image-20221102092920450.png" alt="image-20221102092920450" loading="lazy"> (2)当有程序执行完，需要回收： 情况1：进程4回收之后 <img src="/assets/images/image-20221102093258945.png" alt="image-20221102093258945" loading="lazy"><img src="/assets/images/image-20221102093340707.png" alt="image-20221102093340707" loading="lazy"> 情况2：进程3回收之后 <img src="/assets/images/image-20221102093612368.png" alt="image-20221102093612368" loading="lazy"> 情况3：进程4回收之后 <img src="/assets/images/image-20221102093750188.png" alt="image-20221102093750188" loading="lazy"> 情况4：进程2回收之后 <img src="/assets/images/image-20221102093929988.png" alt="image-20221102093929988" loading="lazy"></p></li></ol><h3 id="_2-非连续分配" tabindex="-1"><a class="header-anchor" href="#_2-非连续分配" aria-hidden="true">#</a> （2）非连续分配</h3><p>为用户进程分配的可以是一些离散的内存空间</p><p><mark>由于太多，不适合在三级标题下记录，因此在此处使用一级标题来笔记<code>分页存储</code></mark></p><h1 id="二十四、分页存储" tabindex="-1"><a class="header-anchor" href="#二十四、分页存储" aria-hidden="true">#</a> 二十四、分页存储</h1><h2 id="_1-基本分页存储管理" tabindex="-1"><a class="header-anchor" href="#_1-基本分页存储管理" aria-hidden="true">#</a> 1.基本分页存储管理</h2><h3 id="_1-基本概念" tabindex="-1"><a class="header-anchor" href="#_1-基本概念" aria-hidden="true">#</a> 1.基本概念</h3><p>将内存空间分为一个个<code>大小相等的分区</code>，比如每个分区4kb，每个分区就是一个<code>页框</code>，也可以叫<code>页帧</code>、<code>内存块</code>、<code>物理块</code>。每个页框有一个编号，即<code>页框号</code>，又叫<code>内存块号</code>、<code>页帧号</code>、<code>物理块号</code>，<strong>页框号从0开始</strong></p><p>将用户进程的地址空间也分为<code>与页框大小相等</code>的多个区域，称为<code>页</code>或<code>页面</code>。每个页面也有一个编号，即<code>页号</code>，也是<strong>从0开始</strong></p><p>页框不能太大，否则会产生过大的内部碎片</p><p>操作系统把一个进程分为的多个页面分配进内存空间，分别放入一个页框中，所以，<code>页面</code>与<code>页框</code>有个<code>一一对应</code>的关系。</p><p>各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中</p><h3 id="_2-地址转换" tabindex="-1"><a class="header-anchor" href="#_2-地址转换" aria-hidden="true">#</a> 2.地址转换</h3><p>分页存储的地址转换</p><figure><img src="/assets/images/image-20221102111036716.png" alt="image-20221102111036716" tabindex="0" loading="lazy"><figcaption>image-20221102111036716</figcaption></figure><figure><img src="/assets/images/image-20221102111440035.png" alt="image-20221102111440035" tabindex="0" loading="lazy"><figcaption>image-20221102111440035</figcaption></figure><figure><img src="/assets/images/image-20221102175225458.png" alt="image-20221102175225458" tabindex="0" loading="lazy"><figcaption>image-20221102175225458</figcaption></figure><p><strong>逻辑地址结构</strong></p><figure><img src="/assets/images/image-20221102175402749.png" alt="image-20221102175402749" tabindex="0" loading="lazy"><figcaption>image-20221102175402749</figcaption></figure><p>为了知道<code>页号</code>对应页面在内存中的地址，有如下页表</p><figure><img src="/assets/images/image-20221102175619073.png" alt="image-20221102175619073" tabindex="0" loading="lazy"><figcaption>image-20221102175619073</figcaption></figure><h3 id="_3-基本地址变换机构" tabindex="-1"><a class="header-anchor" href="#_3-基本地址变换机构" aria-hidden="true">#</a> 3.基本地址变换机构</h3><p>基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。</p><p>通常会在系统中设置一个<code>页表寄存器（PTR）</code>，存放的是<code>页表在内存中的起始地址F</code>和<code>页表长度M</code>。</p><p>进程未执行时，页表的F和M<code>存放在进程控制块（PCB）中</code>，当进程被调度时，操作系统内核会把它们放到页面寄存器中</p><p>流程：</p><figure><img src="/assets/images/image-20221102181311637.png" alt="image-20221102181311637" tabindex="0" loading="lazy"><figcaption>image-20221102181311637</figcaption></figure><figure><img src="/assets/images/image-20221102181213999.png" alt="image-20221102181213999" tabindex="0" loading="lazy"><figcaption>image-20221102181213999</figcaption></figure><p><strong>例题：</strong></p><figure><img src="/assets/images/image-20221102181604763.png" alt="image-20221102181604763" tabindex="0" loading="lazy"><figcaption>image-20221102181604763</figcaption></figure><h3 id="_4-具有快表的地址变换机构" tabindex="-1"><a class="header-anchor" href="#_4-具有快表的地址变换机构" aria-hidden="true">#</a> 4.具有快表的地址变换机构</h3><h4 id="局部性原理" tabindex="-1"><a class="header-anchor" href="#局部性原理" aria-hidden="true">#</a> 局部性原理</h4><figure><img src="/assets/images/image-20221102183517198.png" alt="image-20221102183517198" tabindex="0" loading="lazy"><figcaption>image-20221102183517198</figcaption></figure><h4 id="什么是快表" tabindex="-1"><a class="header-anchor" href="#什么是快表" aria-hidden="true">#</a> 什么是快表</h4><p><code>快表</code>，又称<code>联想寄存器（TLB）</code>，是一种<code>访问速度比内存快很多</code>的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为<code>慢表</code></p><p>快表流程：</p><figure><img src="/assets/images/image-20221102184153075.png" alt="image-20221102184153075" tabindex="0" loading="lazy"><figcaption>image-20221102184153075</figcaption></figure><figure><img src="/assets/images/image-20221102184033463.png" alt="image-20221102184033463" tabindex="0" loading="lazy"><figcaption>image-20221102184033463</figcaption></figure><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><figure><img src="/assets/images/image-20221102184254885.png" alt="image-20221102184254885" tabindex="0" loading="lazy"><figcaption>image-20221102184254885</figcaption></figure><h2 id="_2-两级页表" tabindex="-1"><a class="header-anchor" href="#_2-两级页表" aria-hidden="true">#</a> 2.两级页表</h2><p>单级页表存在的问题：</p><p>问题1：页表必须连续存放，因此当页表很大时，需要占用多个连续的页框</p><p>问题2：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面</p><h3 id="解决问题1" tabindex="-1"><a class="header-anchor" href="#解决问题1" aria-hidden="true">#</a> 解决问题1</h3><p>可将长页表进行分组，使每个内存块刚好可以放入一个分组。</p><p>要为离散分配的页表再建立一张表，成为<code>页目录表</code>，或称<code>外层页表</code>、<code>顶层页表</code></p><p>图示：</p><figure><img src="/assets/images/image-20221102195022772.png" alt="image-20221102195022772" tabindex="0" loading="lazy"><figcaption>image-20221102195022772</figcaption></figure><figure><img src="/assets/images/image-20221102195354719.png" alt="image-20221102195354719" tabindex="0" loading="lazy"><figcaption>image-20221102195354719</figcaption></figure><p>如何实现地址转换：</p><figure><img src="/assets/images/image-20221102195606238.png" alt="image-20221102195606238" tabindex="0" loading="lazy"><figcaption>image-20221102195606238</figcaption></figure></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/vuepress-theme-hope/vuepress-theme-hope/edit/main/docs/zh/posts/操作系统.md" rel="noopener noreferrer" target="_blank" aria-label="https://github.com/EricKiku" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->https://github.com/EricKiku<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item git-info"><div class="update-time"><span class="label">上次编辑于: </span><!----></div><div class="contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 2966678301@qq.com">EricKiku</span><!--]--><!--]--></div></div></footer><nav class="page-nav"><a href="/zh/posts/%E6%97%A5%E8%AF%AD%E7%AC%94%E8%AE%B0.html" class="nav-link prev" aria-label="日语笔记"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon iconfont icon-icon-test" style=""></span>日语笔记</div></a><a href="/zh/posts/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0.html" class="nav-link next" aria-label="项目笔记"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">项目笔记<span class="font-icon icon iconfont icon-project" style=""></span></div></a></nav><div class="giscus-wrapper input-top" id="comment" style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="footer-wrapper"><div class="footer">默认页脚</div><div class="copyright">Copyright © 2023 EricKiku</div></footer></div><!--]--><!----><!--]--></div>
    <script type="module" src="/assets/app-e88a0bdb.js" defer></script>
  </body>
</html>
