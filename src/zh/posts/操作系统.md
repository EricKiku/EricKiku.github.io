---
title: 操作系统笔记
icon: caozuoxitong
category:
  - 课程
  - 随笔
---
# ""


# 一、操作系统

## 1. 操作系统层次

![image-20221024155305809](/assets/images/image-20221024155305809.png)
## 2.定义

`操作系统`(Operating System,OS)是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供用户和其他软件方便的接口和环境，它是计算机系统中最基本的`系统软件`



# 二、操作系统功能和目标

## 1.系统资源的管理者

![image-20221024160818996](/assets/images/image-20221024160818996.png)

## 2.作为硬件和用户之间的接口

![image-20221025090622134](/assets/images/image-20221025090622134.png)

用户接口：

![image-20221025092059509](/assets/images/image-20221025092059509.png)

# 三、操作系统4个特征

​	

![image-20221025093101472](/assets/images/image-20221025093101472.png)

## 1.并发

`并发`：指两个或多个事件在同一时间间隔发生。这些事件`宏观上是同时发生`,但`微观上是交替发生的`

`并行`：指两个或多个事件在同一时刻同时发生	



## 2.共享

`共享`：即资源共享，是指系统中的资源可供内存中多个并发执行的进程使用共同使用

![image-20221025093849891](/assets/images/image-20221025093849891.png)

所谓同时，也是宏观上的，微观上，这些进程可能也是交替进行的



## 并发和共享的关系

如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义

如果失去共享性，则QQ和微信等不能同时访问硬盘资源，就无法实现同步发送文件，也就无法并发



## 3.虚拟

`虚拟`是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体是实际存在的，而逻辑上市用户感受到的。

![image-20221025095831537](/assets/images/image-20221025095831537.png)

## 4.异步

`异步`是指，在多到程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底，而是以某种顺序向前推进



# 四、操作系统的发展与分类

## 1.手工操作阶段

主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低

## 2.单道批处理系统

引入了`脱机输入/输出技术`，使用磁带完成。并`监督程序`负责控制作业的输入、输出

监督程序就是操作系统的雏形



主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。

主要缺点：`内存中仅能有一道程序运行`，只有程序结束之后才能调入下一道程序。`CPU有大量的时间在空闲等待I/O完成`。资源利用率依然很低

## 3.多道批处理系统

操作系统正式诞生。



主要优点：多道程序`并发`执行，`共享`计算机资源。`资源利用率大幅提升`，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。

主要缺点：用户响应时间长，`没有人机交互功能`，用户提交之后不能控制自己作业的执行，只能等待计算机处理完成

## 4.分时操作系统

分时操作系统：计算机以`时间片`为单位`轮流为各个用户服务`，各个用户可以通过终端与计算机进行交互。



主要优点：用户请求可以被即是响应，解决人机交互问题。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到其他人的存在

主要缺点：`不能优先处理一些紧急任务`，操作系统对每个用户都是完全公平的，循环地为每个用户服务一个时间片，不区分任务的紧急性



## 5.实时操作系统

计算机系统接收到信号之后及时进行处理，并且要在规定时间内处理完成事件。实时操作系统的主要特点是`及时性和可靠性`



主要优点：能够优先响应一些紧急任务，某些紧急任务不需要排队



​	![image-20221025192855776](/assets/images/image-20221025192855776.png)



# 五、OS的运行机制和体系结构

## 1. 运行机制

### （1）两种指令

* 特权指令：高危指令，比如内存清空指令。`用户程序无法使用`

* 非特权指令：普通指令。`用户程序可以使用`

### （2）两种处理器状态

* 用户态(目态)：此时CPU只能执行非特权指令

* 和心态(管态)：特权指令，非特权指令都可以执行



> 使用程序状态字寄存器（PSW)中的某标志位来标识当前处理器处于什么状态

### （3）两种程序

* 内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态
* 应用程序：普通应用程序只能执行非特权指令，运行在用户态

## 2.操作系统的内核

![image-20221025194519627](/assets/images/image-20221025194519627.png)

![image-20221025194553756](/assets/images/image-20221025194553756.png)



## 3.操作系统体系结构

![image-20221025194942189](/assets/images/image-20221025194942189.png)



# 六、中断和异常

## 1.中断的概念和作用

1. 当中断发生时，CPU立即进入`核心态`
2. 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理
3. 对于不同的中断信号，会进行不同的处理



发生中断，就意味着需要操作系统介入，开始管理工作，由于操作系统的管理工作需要使用特权指令，所以需要CPU`从用户态转为核心态，使操作系统获得计算机的控制权`，有了中断，才能实现多道程序并发执行



`用户态到核心态`是通过中断实现的，并且只有中断这一个途径

 

## 2.中断的分类

![image-20221026080950359](/assets/images/image-20221026080950359.png)



### 外中断处理过程

![image-20221026081308106](/assets/images/image-20221026081308106.png)



# 七、系统调用

`系统调用`是操作系统提供给应用程序（程序员）使用的接口，可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务



![image-20221026083536572](/assets/images/image-20221026083536572.png)

0

# 八、进程

`程序段、数据段、PCB(进程控制块)`组成了`进程实体`。创建进程就是创建进程实体中的PCB，撤销进程就是撤销进程实体中的PCB。

> PCB是进程存在的唯一标志

`进程`是进程实体的==运行过程==，是系统进行资源分配和调度的一个独立单位



## 1. 进程的组成

![image-20221026101014079](/assets/images/image-20221026101014079.png)

​	![image-20221026101206693](/assets/images/image-20221026101206693.png)



## 2. 进程的组织

![image-20221026102208884](/assets/images/image-20221026102208884.png)



## 3.进程的特征

![image-20221026102632508](/assets/images/image-20221026102632508.png)



# 九、进程的状态与转换

## 1. 进程的状态

三种基本状态

![image-20221026104622917](/assets/images/image-20221026104622917.png)

![image-20221026105335263](/assets/images/image-20221026105335263.png)



## 2.进程的转换

![image-20221026105932540](/assets/images/image-20221026105932540.png)



# 十、进程控制

![image-20221026153713454](/assets/images/image-20221026153713454.png)

> 使用`原语`实现进程控制。原语的特点就是执行期间`不允许中断`，这种操作即为`原子操作`
>
> 原语采用`关中断指令`和`开中断指令`

原语执行在核心态

## 1.原语

![image-20221026154638732](/assets/images/image-20221026154638732.png)

![image-20221026154714560](/assets/images/image-20221026154714560.png)

![image-20221026155212334](/assets/images/image-20221026155212334.png)

![image-20221026155430078](/assets/images/image-20221026155430078.png)



# 十一、进程通信

进程通信就是指，进程之间的信息交换

为了保证安全：`一个进程不能直接访问另一个进程的地址空间`

但是进程通信又是必须的，操作系统提供了一些方法：

1. 共享存储
2. 消息传递
3. 管道通信

## 1.共享存储

两个进程对共享空间的访问必须是互斥的



`基于数据结构的共享`：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢，限制多，是一种低级通信方式

`基于存储区的共享`：在内存中划分一块共享存储区，数组的形式、存放位置，都是由进程控制，而不是操作系统，相比之下，这种共享方式速度更快，是一种`高级通信`方式



## 2.管道通信

![image-20221026170138966](/assets/images/image-20221026170138966.png)

1. 管道只能采用`半双工通信`，某一时刻只能单向传输，如果想要双向传输，则需要设置两个管道。
2. 各进程要`互斥`地访问管道
3. 数据以字符流的形式写入管道，当管道写满时，write()写进程将被阻塞。当管道变空时，此读进程read()将被阻塞
4. 如果没写满，就不允许读。如果没读完，就不允许写
5. 数据一旦被读出，就会消失，所以读进程只能有一个。

## 3. 消息传递

![image-20221026171254351](/assets/images/image-20221026171254351.png)



# 十二、线程/多线程

## 1. 什么是线程

传统的进程是程序的执行的最小单位，引入了线程之后，线程是最小的单位，一个进程可以有多个线程

![image-20221026172128359](/assets/images/image-20221026172128359.png)

线程就是`轻量级`进程。

进程之间可以并发，进程中的线程也可以并发，进一步提高系统的并发度。使得一个进程内可以处理各种任务。

引入线程之后，`进程`只作为`除CPU以外的系统资源的分配单元`，如打印机，内存地址，都是分配给进程的

![image-20221026172539697](/assets/images/image-20221026172539697.png)



## 2.线程的属性

![image-20221026173415914](/assets/images/image-20221026173415914.png)



## 3.线程的实现方式

1. 用户级线程

![image-20221026183005921](/assets/images/image-20221026183005921.png)

2. 内核级线程

![image-20221026183101346](/assets/images/image-20221026183101346.png)

3. 结合使用

![image-20221026183225489](/assets/images/image-20221026183225489.png)



## 4.多线程

`多对一模型：`

![image-20221026183455107](/assets/images/image-20221026183455107.png)

`一对一模型：`

![image-20221026183603681](/assets/images/image-20221026183603681.png)

`多对多模型：`

![image-20221026183702219](/assets/images/image-20221026183702219.png)





# 十三、处理机调度

## 1. 调度概念

当有一堆任务要处理时，但由于资源有限，没法同时处理，就需要确定某种`规则`来`决定`处理这些任务的顺序，这就是调度所研究的问题

## 2. 三个层次

![image-20221027103236067](/assets/images/image-20221027103236067.png)

## 3. 进程调度时机

`进程调度`（低级调度），就是按照某种算法从就绪队列中选择一个进程为其分配处理机

**`需要进行`进程调度与切换的情况：**

1. 当前运行的进程`主动放弃`处理机：
   1. 进程正常终止
   2. 运行中发生异常
   3. 进程主动请求阻塞
2. 当前运行的进程`被动放弃`处理机：
   1. 进程的时间片用完
   2. 有紧急事件处理
   3. 有更高优先级进程进入就绪队列

**`不能进行`进程调度与切换的情况：**

1. 在`处理中断的过程中`。中断处理复杂，很难做到中断处理过程中进行进程切换
2. 进程在`操作系统内核程序临界区中`。
3. 在`原语操作过程中`。原子操作不可中断

> `临界资源：`一个时间段内只允许一个进程使用的资源。各进程需要互斥访问临界资源
>
> `临界区：`访问临界资源的那一段代码

`内核程序临界区`：一般是用来访问`某种内核数据结构`的，比如进程的就绪队列

当进程要进入就绪队列时，会对就绪队列上锁，等代码执行完成之后，再解锁，此时不能进行调度与切换。此时就绪队列时内核程序临界资源

但是当进程要进入如打印机类的临界资源，也会上锁，但是也可以进行调度和切换。

## 4. 进程调度的方式

**`非剥夺调度方式`**

又称`非抢占方式`，即只允许进程主动放弃处理机。即是有更紧急的进程，也依然会使用处理结果。

实现简单，系统开销小，但无法处理紧急任务

**`剥夺调度方式`**

又称`抢占方式`，当一个进程正在使用处理机，如果有更紧急的进程，则立即暂停正在执行的进程，将处理机分配给更紧急的进程

可以优先处理更紧急的进程，也可以让进程按照时间片轮流执行。适合于分时操作需提供，实时操作系统

## 5. 进程切换与过程

`进程调度`：指的就是从就绪队列中选中一个要运行的进程，

`进程切换`：是指一个进程让出处理机，由另一个进程占用处理机的过程



这个过程主要完成了：

1. 对原来运行进程各种数据的保存
2. 对新的进程各种数据的恢复



## 6. 调度算法指标

### 1. CPU利用率

`CPU利用率`：指CPU“忙碌”的时间占比总时间比例

![image-20221027110623621](/assets/images/image-20221027110623621.png)

![image-20221027110738925](/assets/images/image-20221027110738925.png)

### 2. 系统吞吐量

单位时间完成作业的数量

`系统吞吐量=总完成作业/总花费时间`

![image-20221027110932387](/assets/images/image-20221027110932387.png)

### 3. 周转时间

是指从`作业被提交给系统开始，到作业完成为止`的这段时间间隔

`周转时间`=作业完成时间 - 作业提交时间

`平均周转时间=`各作业周转时间之和 / 作业数

`带权周转时间=`作业周转时间  /  作业实际运行的时间	= 	作业完成时间 - 作业提交时间 / 作业实际运行时间



`平均带权周转事件=`各作业带权周转时间之和 / 作业数



### 4.等待时间

是指进程或作业`处于等待处理机状态时间之和`，等待时间越长，满意度越低

### 5.响应时间

是指用户`提交请求`到`首次产生响应`所用的时间



# 十四、调度算法

后三种适合于`交互式系统`

## 1. FCFS

>  **先来先服务FCFS**

`算法思想：`主要从公平角度思考，类似排队买东西

`算法规则：`按照作业/进程到达的先后顺序进行服务

`用于作业/进程调度`：用于作业调度时：考虑哪个作业先到达后备队列。用于进程调度时：考虑哪个进程先到达就绪队列

`是否可抢占`：非抢占式算法

`优缺点：`优点：公平，算法实现简单

​					 缺点：对短作业不利，排在长作业之后，需要等待很长时间

`是否会导致饥饿：`不会



![image-20221027113930687](/assets/images/image-20221027113930687.png)



## 2. SJF

> 短作业优先SJF

`算法思想：`追求最少的平均等待时间，最少的平均

`算法规则：`最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）

`用于作业/进程调度：`两个都可使用，用于进程调度时称为：“短进程优先算法SPF”

`是否可抢占：`SJF和SPF是`非抢占式`，但也有抢占版本：`最短剩余时间优先算法SRTN`

`优缺点`：优点：最短的平均等待时间。缺点：对短作业有利，对长作业不利

`是否会导致饥饿`：会



![image-20221028095109173](/assets/images/image-20221028095109173.png)

![image-20221028095806460](/assets/images/image-20221028095806460.png)



## 3. HRRN

> **高响应比优先算法**

`算法思想：`要综合考虑作业/进程的等待时间和要求服务的时间

`算法规则：`每次调度之前计算各个作业/进程的`响应比`。选择响应比最高的作业/进程为其服务

​					    `响应比=`等待时间+要求服务时间 / 要求服务时间

`用于作业/进程调度：`都可

`是否抢占式：`非抢占式

`优缺点：`综合考虑了等待时间和要求服务时间

`是否会饥饿：`不会

![image-20221028102950354](/assets/images/image-20221028102950354.png)



## 4.RR

以下三种适合`交互式系统`

> **时间片轮转算法**

`算法思想：`公平的，轮流的，为各个进程提供服务，让每个进程在一定时间间隔内都可以得到响应

`算法规则：`按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片，若进程未在一个时间片内完成，则失去处理机，放到队尾重新排队

`用于作业/进程调度：`进程调度。只有作业放入进程之后，才可能被分配到时间片

`是否抢占式：`是抢占式。由时钟装置发出时钟中断通知CPU时间片已到

`优缺点：`公平，响应快，适用于分时操作系统。缺点：开销大，不区分任务的紧急程度

`是否会饥饿：`不会



![image-20221028104735954](/assets/images/image-20221028104735954.png)

![image-20221028105143140](/assets/images/image-20221028105143140.png)

![image-20221028105106093](/assets/images/image-20221028105106093.png)



`时间片`不能太大，太大就会变为`先来先服务`算法，会增大进程响应时间	



## 5. 优先级调度算法

`算法思想：`根据任务的紧急程度来决定处理顺序

`算法规则：`每个作业/进程都有各自的优先级，调度时选择优先级最高的

`用于作业/进程调度：`都可使用，还可以使用在IO调度中

`是否抢占式：`抢占式，非抢占式都有。

`优缺点：`区分紧急程度，重要程度。缺点：如果有很多高优先级进程，则可能导致饥饿

`是否会饥饿：`会



![image-20221029180129648](/assets/images/image-20221029180129648.png)



![image-20221029181010828](/assets/images/image-20221029181010828.png)

## 6. 多级反馈队列调度

`算法思想：`对上述其他算法进行折中权衡

`算法规则：`1.设置多级就绪队列，各级优先队列优先级从高到低，时间片从小到大。2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片

`用于作业/进程调度：`用于进程调度

`是否抢占：`抢占式算法。在k级队列中进程运行过程中，若更上级的队列中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。

`优缺点：`对各类型进程相对公平（FCFS优点）；每个新进程都可以很快得到响应（RR优点）；短进程只用较少的事件即可完成（SJF优点）；可灵活地调整各类进程的偏好程度

`是否导致饥饿`：会

![image-20221029191652803](/assets/images/image-20221029191652803.png)





# 十五、进程同步/互斥

## 1.进程同步

并发具有异步性，有时需要同步处理这些异步问题。

各进程之间推进需要一定的顺序。

## 2.进程互斥

为了实现对临界资源的互斥访问，同时保证系统整体性能，需要以下原则：

1. 空闲让进。临界区空闲时，可以允许一个请求进入临界区的程序立即进入临界区
2. 忙则等待。当已有进程进入临界区，其他试图进入临界区的进程必须等待
3. 有限等待。对请求访问的进程，应保证能在有限时间内进入临界区
4. 让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待



## 3.进程互斥的软件实现

### 1. 单标签法

`算法思想：`两个进程在使用完临界区之后，会把临界区 的使用权限交给另一个进程，也就是每个进程进入临界区的权限只能被另一个进程赋予

![image-20221030112509598](/assets/images/image-20221030112509598.png)



### 2. 双标志检查法

![image-20221030114240298](/assets/images/image-20221030114240298.png)



### 3.双标志后检查法

![image-20221030114407558](/assets/images/image-20221030114407558.png)

### 4.Peterson算法

![image-20221030114927003](/assets/images/image-20221030114927003.png)

Peterson算法用软件解决了进程互斥问题，遵循了`空闲让进，忙则等待，有限等待 三个原则。`但是没有遵循`让权等待`

## 4.进程互斥的硬件实现

### 1. 中断屏蔽方法

![image-20221030163311867](/assets/images/image-20221030163311867.png)

### 2.TestAndSet指令

![image-20221030164305503](/assets/images/image-20221030164305503.png)

### 3.Swap指令

![image-20221030164618214](/assets/images/image-20221030164618214.png)



# 十六、信号量机制

用户进程可以通过使用操作系统提供的`一对原语`来对`信号量`进行操作，从而很方便的实现了进程互斥、进程同步

`信号量`其实就是一个变量，可以用`一个信号量表示系统中某种资源的数量`



`一对原语：wait(S)`原语和`signal(S)`原语，可以把原语理解为自己写的函数，函数名为wait和signal，括号里的`信号量S`其实就是函数调用时传入的一个参数。

`wait、signal`原语常简称为`P、V操作`。因此，做题时常把wait(S和signal(S)两个操作写为`P(S)、V(S)`



## 1. 整形信号量

![image-20221030184919026](/assets/images/image-20221030184919026.png)



## 2. 记录型信号量

![image-20221030191334035](/assets/images/image-20221030191334035.png)



## 3. 信号量机制实现进程互斥

![image-20221030192021395](/assets/images/image-20221030192021395.png)



## 4. 信号量机制实现进程同步

![image-20221030201007592](/assets/images/image-20221030201007592.png)

## 5.实现进程的同步关系

![image-20221030201357910](/assets/images/image-20221030201357910.png)



# 十七、生产者消费者

系统中有一组生产者进程和消费者进程，生产者进程每次生产一个数据放入缓存区，消费者进程每次从缓冲区中取出一个数据并使用

生产者、消费者共享一个初始为空、大小为n的缓冲区

只有缓冲区没满时，生产者才能把数据放入缓冲区，否则必须等待。只有缓冲区不空时，消费者才能从中取出产品，否则必须等待

缓冲区是`临界资源`，各进程必须互斥的访问

![image-20221030202940683](/assets/images/image-20221030202940683.png)

## 1. 多生产者多消费者

![image-20221031091429087](/assets/images/image-20221031091429087.png)

![image-20221031091501823](/assets/images/image-20221031091501823.png)



如果缓冲区大小大于1，就必须专门放置一个互斥信号量mutex来保证互斥访问缓冲区



# 十八、吸烟者问题

![image-20221031092527012](/assets/images/image-20221031092527012.png)

如何实现进程同步和进程互斥

![image-20221031093300160](/assets/images/image-20221031093300160.png)



# 十九、读者、写者

![image-20221031093738934](/assets/images/image-20221031093738934.png)

![image-20221031094938348](/assets/images/image-20221031094938348.png)

![image-20221031095025917](/assets/images/image-20221031095025917.png)



# 二十、哲学家进餐问题

![image-20221031095631870](/assets/images/image-20221031095631870.png)

==这个方法不可取==

解决进程死锁

![image-20221031100721047](/assets/images/image-20221031100721047.png)

# 二十一、管程

为了解决PV操作的复杂，使用管程来简化这些操作

## 1.管程解决生产者消费者问题

![image-20221031102027887](/assets/images/image-20221031102027887.png)

![image-20221031102327873](/assets/images/image-20221031102327873.png)

![image-20221031102511010](/assets/images/image-20221031102511010.png)

# 二十二、死锁

## 1.死锁、饥饿、死循环

`死锁：`各进程互相等待对方手里的资源，导致各进程互相阻塞，无法向前推进的现象

`饥饿：`长期得不到想要的资源，某进程无法向前推进的现象，。

`死循环：`跳不出某个循环，有时是bug导致，有时是故意设置

## 2.死锁发生的条件

必须满足以下四个条件：

`互斥条件：`只有对必须互斥使用的资源的争抢才会导致死锁

`不剥夺条件：`进程所获得的资源在未使用完之前，不能 由其他进程夺走资源，只能主动释放

`请求和保持条件：`进程已经保持了一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又不释放自己的资源

`循环等待条件：`链中的每一个进程已获得的资源同时被下一个进程所请求

`注意：`发生死锁时一定有循环等待，但是发生循环等待时未必死锁

## 3.死锁的处理策略

1. 预防死锁。破坏死锁产生的四个必要条件中的一个
2. 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）
3. 死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁

## 4.预防死锁

### 1.破坏互斥条件

把互斥的资源改为允许共享使用的资源。如`SPOOLing技术`

缺点：不是所有的资源都可以改造成可共享使用的资源

### 2.破坏不剥夺条件

1. 当某个进程请求新的资源得不到时，必须立刻释放已拥有的资源，等待再重新申请。也就是说，即是某些资源尚未使用完，也要主动释放。
2. 当某个进程需要的资源被其他进程占用时，可以由操作系统协助，将想要的资源强行剥夺。

缺点：实现复杂。释放资源可能导致前一段工作失效



### 3.破坏请求和保持条件

可以采用静态分配方法，即进程在运行前，申请完它所需要的全部资源，在资源未完成之前，不让进程运行

缺点：资源利用率低，可能导致饥饿

### 4.破坏循环等待条件

可采用`顺序资源分配法`。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源。

一个进程只有已占有小编号的资源时，才有资格申请大编号的资源。

缺点：不方便增加新的设备，需要重新分配所有的编号。进程实际使用资源的顺序可能和序号递增顺序不一致，会导致资源浪费。必须按规定次序申请资源，用户编程麻烦

## 5.避免死锁

### 1. 什么是安全序列

`安全序列：`就是指如果系统按照一种序列分配资源，则每个进程都能顺利完成。只要找到一个安全序列，系统就是`安全状态`。安全序列可以有多个。

如果分配了资源之后，系统中找不到任何一个安全序列，系统就进入了`不安全状态`。

如果系统处于`安全状态`，就`一定不发发生死锁`，如果系统进入`不安全状态`，就`可能发生死锁`。

但发生死锁时，一定是在不安全状态下。

`银行家算法：`在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答应资源分配请求。

### 2.银行家算法

![image-20221031164939094](/assets/images/image-20221031164939094.png)

![image-20221031165025486](/assets/images/image-20221031165025486.png)



## 6.死锁的检测和解除

### 1.死锁的检测

为了能对系统是否已经发生了死锁进行检测：

1. 用`某种数据结构`来保存资源的请求和分配信息。
2. 提供`一种算法`，利用上述信息来检测系统是否已经进入死锁状态

![image-20221031170701813](/assets/images/image-20221031170701813.png)

如果系统中剩余的可用资源数足够`满足进程的需求`，那么这个进程暂时是不会阻塞的，可以顺利地执行下去，如果这个进程执行结束了，把资源归还给系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去

![image-20221031174044568](/assets/images/image-20221031174044568.png)

如果不能消除`所有边`，那么就是发生了死锁。上面的图就是一个死锁

检测死锁的算法：

1. 在资源分配图中，找出既不阻塞又不是孤点的进程Pi，就是可以消掉边的点，消去它的请求边和分配边，使之成为孤立的节点。在上图不是死锁的图中，P1满足，把P1的边消掉
2. 进程Pi所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程变为非阻塞进程。
3. 如果消去所有的边，则称该图是`可完全简化的`

`死锁定理：`如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁

### 2.解除死锁

1. `资源剥夺法。`挂起某些死锁进程，暂时放在外存，并剥夺它的资源，将这些资源分配给其他的死锁进程。
2. `撤销进程法。`强制撤销部分进程，甚至全部进程。并剥夺这些进程的资源。实现简单，代价大，会让已经快结束的进程功亏一篑
3. `进程回退法。`让一个或多个进程回退到足以避免死锁的地步，这就要求系统要记录进程的历史信息，设置还原点



# 二十三、内存

>  操作系统是系统资源的管理者，当然也需要对内存进行管理，需要管理的有：
>
> 1. 负责`内存空间的分配与回收`
> 2. 提供从逻辑上`对内存空间进行扩充`
> 3. 提供`地址转换功能`，负责程序的逻辑地址与物理地址的转换
> 4. 提供`内存保护`功能，保证各进程在各自存储空间内运行，互不干扰

在内存中编译时，只关心`相对位置`，实际放入内存时，再想办法根据起始位置得到`绝对地址`

`相对地址`又称`逻辑地址`，`绝对地址`又称`物理地址`

![image-20221031193032345](/assets/images/image-20221031193032345.png)

## 1.装入方式

装入的三种方式（用三种不同的方法完成`逻辑地址 到 物理地址 的转换`）：

1. 绝对装入 
   在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存
2. 静态重定位
   ![image-20221031192754718](/assets/images/image-20221031192754718.png)
3. 动态重定位
   ![image-20221031192929747](/assets/images/image-20221031192929747.png)

## 2.链接方式

![image-20221031193340739](/assets/images/image-20221031193340739.png)

## 3.内存保护

![image-20221031195146659](/assets/images/image-20221031195146659.png)

![image-20221031195256953](/assets/images/image-20221031195256953.png)

## 4.覆盖与交换

计算机内存较小，无法把一个大型软件全部运行

之后引入`覆盖技术`，用来`解决“程序大小超过物理内存总和”`的问题

覆盖技术思想：将`程序分为多个段`，常用的段常驻内存，不常用的段在需要时调入内存

内存中分为一个`“固定区”`，和若干个`“覆盖区”`

需要常驻内存的段放在`固定区`，调入后就不再调出，除非运行结束

不常用的段放在`“覆盖区”`，需要用时调入内存，用不到时调出内存

![image-20221031201127995](/assets/images/image-20221031201127995.png)



`交换技术设计思想`：内存空间紧张时，系统将内存中某些进程暂时调出外存，把外存中某些已具备运行条件的进程换入内存

![image-20221031202417496](/assets/images/image-20221031202417496.png)

![image-20221031202730509](/assets/images/image-20221031202730509.png)

![image-20221031203139203](/assets/images/image-20221031203139203.png)



## 5.内存空间的分配与回收

`内部碎片：`分配个某进程的内存区域中，如果有些部分没有用上

`外部碎片：`是指内存中的某些空闲分区由于太小而难以利用

### （1）连续分配管理方式

为用户分配一段连续的内存空间

> **单一连续分配**

在单一连续分配方式中，内存被分为`系统区`和`用户区`。系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用于进程相关数据。

单一连续分配`只能有一道用户程序`，用户程序独占整个用户区空间。

有点：实现简单，无外部碎片；可以采用覆盖技术扩充内存。不一定需要采取内存保护

用于早期的计算机系统

缺点：只能用于单用户，单任务的操作系统中，有`内部碎片`，存储器 利用率极低。

`内部碎片：`分配给某进程的内存区域中，有些部分没有用上，就是内部碎片

![image-20221101111712854](/assets/images/image-20221101111712854.png)

> **固定分区分配**

20世纪60年代，出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会互相干扰，于是将整个`用户空间`划分为`若干个固定大小的分区`，在`每个分区中只装入一道作业`。

![image-20221101111834019](/assets/images/image-20221101111834019.png)

![image-20221101111859551](/assets/images/image-20221101111859551.png)

分区大小相等：缺乏灵活性，但是很`适合用于一台计算机控制多个相同对象的场合`

分区大小不等：增加了灵活性，可以满足不同大小的进程需求。

操作系统需要建立一个数据结构>`分区说明表`，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列，每个表项包括对应分区的`大小、起始地址、状态`，

![image-20221102090746058](/assets/images/image-20221102090746058.png)

当用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的，未分配的分区，将分区分配给该程序，然后状态改为：已分配

优点：实现简单，`无外部碎片`

缺点：1.程序太大时，需要采用覆盖技术，覆盖技术又会降低性能。2.会产生内部碎片，内存利用率低

> **动态分区分配**

又称`可变分区分配`，这种分配方式，`不会预先划分内存区`，在程序装入内存时，根据`进程的大小动态的创建分区`，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。

![image-20221102091650516](/assets/images/image-20221102091650516.png)

1. 系统要用什么样的数据结构记录内存的使用情况
   两种数据结构：`空闲分区表`和`空闲分区链`
   ![image-20221102092150308](/assets/images/image-20221102092150308.png)
   ![image-20221102092242912](/assets/images/image-20221102092242912.png)

2. 当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配

   ![image-20221102095610234](/assets/images/image-20221102095610234.png)

   （1）首次适应算法
       `算法思想：`每次都从低地址开始查找，找到第一个能满足大小的空闲分区
       `实现方法：`空闲分区表以`地址递增的次序排列`，每次分配内存时，按顺序查找空闲分区链，找到第一个满足的空闲分区

   （2）最佳适应算法

   ​	`算法思想：`为了在大进程来到的时候，有大片空闲分区，所以优先使用最小的空闲区

   ​	`实现：`空闲分区表按`容量递增次序排列`，每次分配内存时，按顺序查找空闲分区表或链，找到的第一个空闲分区，就是最小的满足进程的分区

   （3）最坏适应算法

   又称`最大适应算法`

   ​	`算法思想：`为了解决最佳适应算法遗留的问题：留下太多难以利用的小碎片。在每次分配时优先使用最大的连续空闲区，这样留下的空闲分区不会太小

   ​	`实现：`按`容量递减次序排序`，按顺序查找，找到大小满足的第一个空闲分区
   ​	`缺点：`没有给大进程留足够的空闲分区

   （4）邻近适应算法

   ​	`算法思想：`每次查找都从上次查找结束的位置开始检索。解决了每次从链头查找的开销

   ​	`实现：`空闲分区以`地址递增循环排列`，形成一个循环链表，每次分配内存时，从上次查找结束的位置开始查找空闲分区链，找到第一个能满足的空闲分区

3. 如何进行分区的分配和回收操作
   ![image-20221102092616982](/assets/images/image-20221102092616982.png)
   (1)当有一个4MB的进程需要分配，有两种方式：
       分给分区1：![image-20221102092842674](/assets/images/image-20221102092842674.png)
       分给分区3：![image-20221102092920450](/assets/images/image-20221102092920450.png)
   (2)当有程序执行完，需要回收：
       情况1：进程4回收之后
   ![image-20221102093258945](/assets/images/image-20221102093258945.png)
   ![image-20221102093340707](/assets/images/image-20221102093340707.png)
       情况2：进程3回收之后
   ![image-20221102093612368](/assets/images/image-20221102093612368.png)
       情况3：进程4回收之后
   ![image-20221102093750188](/assets/images/image-20221102093750188.png)
       情况4：进程2回收之后
   ![image-20221102093929988](/assets/images/image-20221102093929988.png)



### （2）非连续分配

为用户进程分配的可以是一些离散的内存空间

==由于太多，不适合在三级标题下记录，因此在此处使用一级标题来笔记`分页存储`==

# 二十四、分页存储

## 1.基本分页存储管理

### 1.基本概念

将内存空间分为一个个`大小相等的分区`，比如每个分区4kb，每个分区就是一个`页框`，也可以叫`页帧`、`内存块`、`物理块`。每个页框有一个编号，即`页框号`，又叫`内存块号`、`页帧号`、`物理块号`，**页框号从0开始**

将用户进程的地址空间也分为`与页框大小相等`的多个区域，称为`页`或`页面`。每个页面也有一个编号，即`页号`，也是**从0开始**

页框不能太大，否则会产生过大的内部碎片

操作系统把一个进程分为的多个页面分配进内存空间，分别放入一个页框中，所以，`页面`与`页框`有个`一一对应`的关系。

各个页面不必连续存放，也不必按先后顺序来，可以放到不相邻的各个页框中

### 2.地址转换

分页存储的地址转换

![image-20221102111036716](/assets/images/image-20221102111036716.png)

![image-20221102111440035](/assets/images/image-20221102111440035.png)

![image-20221102175225458](/assets/images/image-20221102175225458.png)

**逻辑地址结构**

![image-20221102175402749](/assets/images/image-20221102175402749.png)

为了知道`页号`对应页面在内存中的地址，有如下页表

![image-20221102175619073](/assets/images/image-20221102175619073.png)

### 3.基本地址变换机构

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。

通常会在系统中设置一个`页表寄存器（PTR）`，存放的是`页表在内存中的起始地址F`和`页表长度M`。

进程未执行时，页表的F和M`存放在进程控制块（PCB）中`，当进程被调度时，操作系统内核会把它们放到页面寄存器中

流程：

![image-20221102181311637](/assets/images/image-20221102181311637.png)

![image-20221102181213999](/assets/images/image-20221102181213999.png)

**例题：**

![image-20221102181604763](/assets/images/image-20221102181604763.png)

### 4.具有快表的地址变换机构

#### 局部性原理

![image-20221102183517198](/assets/images/image-20221102183517198.png)

#### 什么是快表

`快表`，又称`联想寄存器（TLB）`，是一种`访问速度比内存快很多`的高速缓冲存储器，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，内存中的页表常称为`慢表`

快表流程：

![image-20221102184153075](/assets/images/image-20221102184153075.png)

![image-20221102184033463](/assets/images/image-20221102184033463.png)

### 小结

![image-20221102184254885](/assets/images/image-20221102184254885.png)



## 2.两级页表

单级页表存在的问题：

问题1：页表必须连续存放，因此当页表很大时，需要占用多个连续的页框

问题2：没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面

### 解决问题1

可将长页表进行分组，使每个内存块刚好可以放入一个分组。

要为离散分配的页表再建立一张表，成为`页目录表`，或称`外层页表`、`顶层页表`

图示：

![image-20221102195022772](/assets/images/image-20221102195022772.png)

![image-20221102195354719](/assets/images/image-20221102195354719.png)

如何实现地址转换：

![image-20221102195606238](/assets/images/image-20221102195606238.png)
